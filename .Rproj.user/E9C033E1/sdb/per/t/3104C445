{
    "collab_server" : "",
    "contents" : "#!/cygdrive/c/Program Files/R/R-3.3.2patched/bin/R\n\n\n# Helper Functions\n##################\n# Erik.Leppo@tetratech.com (EWL)\n# 20150805\n##################\n\n# functions\nfun.CamelCase <- function(string)\n{\n  return (paste0(toupper(substring(string, 1, 1)),\n                tolower(substring(string, 2, nchar(string)))))\n}\n\nfun.ImportFolderPath <- function(folder_path, script_operation)\n{\n  if (folder_path != \"\")\n  { if (! dir.exists(folder_path))\n  {\n    stop(paste0(\"1. Unable to find supplied import folder path:\\n\\t\",folder_path))\n  }\n  } else {\n    switch(script_operation,\n           \"GetGageData\" = {\n             folder_path<-config.Folder.RawData\n           },\n           \"QCRaw\" = {\n             folder_path<-config.Folder.RawData\n           },\n           \"ReportQC\" = {\n             folder_path<-config.Folder.QCData\n           },\n           \"GetGageData\" = {\n             folder_path<-config.Folder.QCData\n           },\n           \"Aggregate\" = {\n             folder_path <- config.Folder.AggData\n           },\n           \"ReportAggregate\" = {\n             folder_path <- config.Folder.AggData\n           },\n           \"SummaryStats\" = {\n             folder_path <- config.Folder.AggData\n           },\n           stop(paste0(\"unable to process Operation == \", script_operation))\n    )\n\n    if ( ! dir.exists(folder_path) )\n    {\n      stop(paste0(\"2. Unable to find default import folder path for operation \", script_operation, \":\\n\\t\", folder_path))\n    }\n  }\n  return(folder_path)\n}\n\nfun.ExportFolderPath <- function(folder_path, script_operation)\n{\n  if (folder_path != \"\")\n  { if (! dir.exists(folder_path))\n  {\n    stop(paste0(\"1. Unable to find supplied import folder path:\\n\\t\",folder_path))\n  }\n  } else {\n    switch(script_operation,\n           \"GetGageData\" = {\n             folder_path = config.Folder.RawData\n           },\n           \"QCRaw\" = {\n             folder_path = config.Folder.QCData\n           },\n           \"ReportQC\" = {\n             folder_path = config.Folder.QCData\n           },\n           \"GetGageData\" = {\n             folder_path = config.Folder.AggData\n           },\n           \"Aggregate\" = {\n             folder_path = config.Folder.AggData\n           },\n           \"ReportAggregate\" = {\n             import_folder_path <- config.Folder.AggData\n           },\n           \"SummaryStats\" = {\n             folder_path = config.Folder.StatsData\n           },\n           stop(paste0(\"unable to process myData.Operation == \", script_operation))\n    )\n\n    if ( ! dir.exists(folder_path) )\n    {\n      stop(paste0(\"2. Unable to find default import folder path for operation \", script_operation, \":\\n\\t\", folder_path))\n    }\n  }\n  return(folder_path)\n}\n\n#\n# print message to console\n#\nfun.Msg.Status <- function(fun.status,\n                           fun.item.num.current,\n                           fun.item.num.total,\n                           fun.item.name)\n{\n  flog.debug(paste0(\"Processing item \",\n              fun.item.num.current,\" of \", fun.item.num.total,\", \",\n              fun.status, \", \", fun.item.name))\n}\n\n#\n# write message to log file\n#\nfun.write.log <- function(fun.Log, fun.Date, fun.Time)\n{\n  write.table(fun.Log,\n              file = file.path(config.Folder.Logs, paste0(\"LOG.Items.\", fun.Date, \".\", fun.Time, \".tab\")),\n              sep=\"\\t\",\n              row.names=FALSE,\n              col.names=TRUE)\n}\n\n#\n# QC check for variables in data (20160204)\n# referenced in calling script right after data is imported.\n# Required fields: myName.SiteID & (myName.DateTime | (myName.Date & myName.Time))\n#\nfun.helper.CheckRequiredFields <- function(fun.names, fun.File)\n{\n  #####\n  # SiteID\n  # if(myName.SiteID %in% fun.names == FALSE)\n  # {\n  #   myMsg <- paste0(\"\\n\n  #     The SiteID column name (\",myName.SiteID,\") is mispelled or missing from your data file.\n  #     The scripts will not work properly until you change the SiteID variable 'myName.SiteID' in the script 'UserDefinedValue.R' or modify your file.\n  #      \\n\n  #     File name and path:\n  #     \\n\n  #     \",fun.File,\"\n  #     \\n\n  #     Column names in current file are below.\n  #     \\n\"\n  #     ,list(fun.names))\n  #   stop(myMsg)\n  # }\n\n  #####\n  # Date.Time | (Date & Time)\n  if(myName.DateTime %in% fun.names==FALSE & (myName.Date %in% fun.names==FALSE | myName.Time %in% fun.names==FALSE))\n  {\n    myMsg <- paste0(\"\nThe DateTime (\",myName.DateTime,\") and/or Date (\",myName.Date,\") and/or Time (\",myName.Time,\") column names are mispelled or missing from your data file.\nEither 'Date.Time' or both of 'Date' and 'Time' are required.\nThe scripts will not work properly until you change the variables 'myName.DateTime' and/or 'myName.Date' and/or 'myName.Time'\nin the script 'UserDefinedValue.R' or modify your input file.\n\nFile name and path:\\n\\t\",fun.File,\"\n\nColumn names in current file are below.\n\",list(fun.names))\n\n    stop(myMsg)\n  }\n}\n\n#\n# QC check of date and time fields (20170115)\n# Excel can mess up date formats in CSV files even when don't intentionally change.\n# borrow code from fun.QC.R, fun.QC, step 5 ~ line 245\n# Access this code after QC for the date and time fields in the Aggregate and Summary Operations\n# takes as input a data frame and returns it with changes\n#\nfun.QC.datetime <- function(fun.df){\n  #\n  # 5.  QC Date and Time fields\n  #\n  ############\n  # may have to tinker with for NA fields\n  ##############\n  # get format - if all data NA then get an error\n  #\n  # backfill first?\n  #\n  # may have to add date and time (data) from above when add the missing field.\n  #if does not exists then add field and data.\n  #\n  # if entire field is NA then fill from other fields\n  # Date\n  myField   <- myName.Date\n  fun.df[,myField][all(is.na(fun.df[,myField]))] <- fun.df[,myName.DateTime]\n  # Time\n  myField   <- myName.Time\n  fun.df[,myField][all(is.na(fun.df[,myField]))] <- fun.df[,myName.DateTime]\n  # DateTime\n  #myField   <- myName.DateTime\n  # can't fill fill from others without knowing the format\n  #\n  # get current file date/time records so can set format\n  # Function below gets date or time format and returns R format\n  # date_time is split and then pasted together.\n  # if no AM/PM then 24hr time is assumed\n  format.Date     <- fun.DateTimeFormat(fun.df[,myName.Date],\"Date\")\n  format.Time     <- fun.DateTimeFormat(fun.df[,myName.Time],\"Time\")\n  #format.DateTime <- fun.DateTimeFormat(data.import[,myName.DateTime],\"DateTime\")\n  # get error if field is NA, need to fix\n  # same for section below\n  #\n  # 20160322, new section, check for NA and fill if needed\n  if (length(na.omit(fun.df[,myName.DateTime]))==0){\n    # move 5.2.1 up here\n    myField   <- myName.DateTime\n    myFormat  <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==\"\"]\n    #                                                                       ,data.import[,myName.Time][data.import[,myField]==\"\"],sep=\"\")\n    #                                                                 ,format=myFormat,usetz=FALSE)\n    fun.df[,myField][is.na(fun.df[,myField])] <- strftime(paste(fun.df[,myName.Date][is.na(fun.df[,myField])]\n                                                                          ,fun.df[,myName.Time][is.na(fun.df[,myField])]\n                                                                          ,sep=\" \")\n                                                                    ,format=myFormat,usetz=FALSE)\n  }\n  format.DateTime <- fun.DateTimeFormat(fun.df[,myName.DateTime],\"DateTime\")\n  #\n  # QC\n  #  # format.Date <- \"%Y-%m-%d\"\n  #   format.Time <- \"%H:%M:%S\"\n  #   format.DateTime <- \"%Y-%m-%d %H:%M\"\n  #\n  # 5. QC Date and Time\n  # 5.1. Convert all Date_Time, Date, and Time formats to expected format (ISO 8601)\n  # Should allow for users to use different time and date formats in original data\n  # almost worked\n  #data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime] <- strftime(data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime]\n  #                                                                                   ,format=\"%Y-%m-%d\")\n  # have to do where is NOT NA because will fail if the first item is NA\n  # assume all records have the same format.\n  #\n  # 5.1.1. Update Date to \"%Y-%m-%d\" (equivalent to %F)\n  myField   <- myName.Date\n  myFormat.In  <- format.Date #\"%Y-%m-%d\"\n  myFormat.Out <- myFormat.Date #\"%Y-%m-%d\"\n  fun.df[,myField][!is.na(fun.df[,myField])] <- format(strptime(fun.df[,myField][!is.na(fun.df[,myField])],format=myFormat.In)\n                                                                 ,format=myFormat.Out)\n  # 5.1.2. Update Time to \"%H:%M:%S\" (equivalent to %T) (uses different function)\n  myField   <- myName.Time\n  myFormat.In  <- format.Time #\"%H:%M:%S\"\n  myFormat.Out <- myFormat.Time #\"%H:%M:%S\"\n  fun.df[,myField][!is.na(fun.df[,myField])] <- format(as.POSIXct(fun.df[,myField][!is.na(fun.df[,myField])],format=myFormat.In)\n                                                                 ,format=myFormat.Out)\n  # 5.1.3. Update DateTime to \"%Y-%m-%d %H:%M:%S\" (equivalent to %F %T)\n  myField   <- myName.DateTime\n  myFormat.In  <- format.DateTime #\"%Y-%m-%d %H:%M:%S\"\n  myFormat.Out <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n  fun.df[,myField][!is.na(fun.df[,myField])] <- format(strptime(fun.df[,myField][!is.na(fun.df[,myField])],format=myFormat.In)\n                                                                 ,format=myFormat.Out)\n  #   # strptime adds the timezome but drops it when added back to data.import (using format)\n  #   #######################################################\n  #   # doesn't work anymore, worked when first line was NA\n  #   #######################################################\n  #   data.import <- y\n  #   x<-data.import[,myField][!is.na(data.import[,myField])]\n  #   (z<-x[2])\n  #   (a <- strptime(z,format=myFormat.In))\n  #   (b <- strptime(x,format=myFormat.In))\n  #   # works on single record but fails on vector with strftime\n  #   # strptime works but adds time zone (don't like but it works)\n  #\n  #\n  # 5.2. Update DateTime, Date, and Time if NA based on other fields\n  # 5.2.1. Update Date_Time if NA (use Date and Time)\n  myField   <- myName.DateTime\n  myFormat  <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n  #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==\"\"]\n  #                                                                       ,data.import[,myName.Time][data.import[,myField]==\"\"],sep=\"\")\n  #                                                                 ,format=myFormat,usetz=FALSE)\n  fun.df[,myField][is.na(fun.df[,myField])] <- strftime(paste(fun.df[,myName.Date][is.na(fun.df[,myField])]\n                                                                        ,fun.df[,myName.Time][is.na(fun.df[,myField])]\n                                                                        ,sep=\" \")\n                                                                  ,format=myFormat,usetz=FALSE)\n  # 5.2.2. Update Date if NA (use Date_Time)\n  myField   <- myName.Date\n  myFormat  <- myFormat.Date #\"%Y-%m-%d\"\n  #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Date]==\"\"]\n  #                                                               ,format=myFormat,usetz=FALSE)\n  fun.df[,myField][is.na(fun.df[,myField])] <- strftime(fun.df[,myName.DateTime][is.na(fun.df[,myField])]\n                                                                  ,format=myFormat,usetz=FALSE)\n  # 5.2.3. Update Time if NA (use Date_Time)\n  myField   <- myName.Time\n  myFormat  <- myFormat.Time #\"%H:%M:%S\"\n  #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Time]==\"\"]\n  #                                                               ,format=myFormat,usetz=FALSE)\n  fun.df[,myField][is.na(fun.df[,myField])] <- as.POSIXct(fun.df[,myName.DateTime][is.na(fun.df[,myField])]\n                                                                    ,format=myFormat,usetz=FALSE)\n  #\n  # old code just for reference\n  # 5.5. Force Date and Time format\n  #   data.import[,myName.Date] <- strftime(data.import[,myName.Date],format=\"%Y-%m-%d\")\n  #   data.import[,myName.Time] <- as.POSIXct(data.import[,myName.Time],format=\"%H:%M:%S\")\n  #   data.import[,myName.DateTime] <- strftime(data.import[,myName.DateTime],format=\"%Y-%m-%d %H:%M:%S\")\n  #\n  #\n  # Create Month and Day Fields\n  # month\n  #     myField   <- \"month\"\n  #     data.import[,myField] <- data.import[,myName.Date]\n  #     myFormat  <- \"%m\"\n  #     data.import[,myField][!is.na(data.import[,myName.Date])] <- strftime(data.import[,myName.Date][!is.na(data.import[,myName.DateTime])]\n  #                                                                     ,format=myFormat,usetz=FALSE)\n  fun.df[,\"month\"] <- as.POSIXlt(fun.df$Date)$mon+1\n  # day\n  #     myField   <- \"day\"\n  #     data.import[,myField] <- data.import[,myName.Date]\n  #     myFormat.In  <- myFormat.Date #\"%Y-%m-%d\"\n  #     myFormat.Out <- \"%d\"\n  #     data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n  #                                                                    ,format=myFormat.Out)\n  fun.df[,\"day\"] <- as.POSIXlt(fun.df$Date)$mday\n  #\n  #     # example of classes for POSIXlt\n  #     Sys.time()\n  #     unclass(as.POSIXlt(Sys.time()))\n  #     ?DateTimeClasses\n\n  #\n  return(fun.df)\n}\n",
    "created" : 1488990411126.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1039876125",
    "id" : "3104C445",
    "lastKnownWriteTime" : 1490714465,
    "last_content_update" : 1490714465864,
    "path" : "~/tn_realtime/working/R_scripts/libs/fun.Helper.R",
    "project_path" : "libs/fun.Helper.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}