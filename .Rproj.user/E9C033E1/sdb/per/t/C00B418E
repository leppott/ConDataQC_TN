{
    "collab_server" : "",
    "contents" : "# Sourced Routine\n##################\n# Aggregate Data\n# combine Single Site and Date Range\n# add all data types into columns, merge time stamps\n#########################\n# make user script smaller and easier to understand\n# not a true function, needs defined variables in calling script\n# if change variable names in either file have to update the other\n##################\n# Erik.Leppo@tetratech.com (EWL)\n# 20151021\n##################\n# 20170116, EWL\n# added date & time QC\n##################\n# assumes use of CSV.  If using TXT have to modify list.files(pattern), read.csv(), and write.csv()\n#\n# Basic Operations:\n# load all files in data directory\n# find ones specified by user\n# subset if necessary\n# combine\n# save\n# (repeats much of fun.QCauto)\n\nfun.AggregateData <- function(fun.myData.SiteID\n                             ,fun.myData.Type\n                             ,fun.myData.DateRange.Start\n                             ,fun.myData.DateRange.End\n                             ,fun.myDir.SUB.import\n                             ,fun.myDir.SUB.export) {##FUN.fun.QCauto.START\n  #\n  # Error Checking - only 1 SiteID and 1 DataType\n  if(length(fun.myData.SiteID)!=1){\n    myMsg <- \"Function can only handle 1 SiteID.\"\n    stop(myMsg)\n  }\n  if(length(fun.myData.Type)!=1){\n    myMsg <- \"Function can only handle 1 Data Type.\"\n    stop(myMsg)\n  }\n  #\n  # Convert Data Type to proper case\n  fun.myData.Type <- paste(toupper(substring(fun.myData.Type,1,1)),tolower(substring(fun.myData.Type,2,nchar(fun.myData.Type))),sep=\"\")\n\n  #\n  # data directories\n  myDir.data.import <- fun.myDir.SUB.import\n  myDir.data.export <- fun.myDir.SUB.export\n\n  myDate <- format(Sys.Date(),\"%Y%m%d\")\n  myTime <- format(Sys.time(),\"%H%M%S\")\n  #\n  # Verify input dates, if blank, NA, or null use all data\n  # if DateRange.Start is null or \"\" then assign it 1900-01-01\n  if (is.na(fun.myData.DateRange.Start)==TRUE||fun.myData.DateRange.Start==\"\"){fun.myData.DateRange.Start<-DateRange.Start.Default}\n  # if DateRange.End is null or \"\" then assign it today\n  if (is.na(fun.myData.DateRange.End)==TRUE||fun.myData.DateRange.End==\"\"){fun.myData.DateRange.End<-DateRange.End.Default}\n  #\n  # Read in list of files to work on, uses all files matching pattern (\"\\\\.csv$\")\n  # ## if change formats will have to make modifications (pattern, import, export)\n  files2process = list.files(path=myDir.data.import, pattern=\" *.csv\")\n  # head(files2process)\n  #\n  #\n  # Define Counters for the Loop\n  intCounter <- 0\n  intCounter.Stop <- length(files2process)\n  intItems.Total <- intCounter.Stop\n  print(paste(\"Total files to process = \",intItems.Total,sep=\"\"))\n  flush.console()\n  myItems.Complete  <- 0\n  myItems.Skipped   <- 0\n  myFileTypeNum.Air <- 0\n  myFileTypeNum.Water <- 0\n  myFileTypeNum.AW <- 0\n  myFileTypeNum.Gage <- 0\n  strFile.SiteID.Previous <- \"\"\n  #\n  # Create Log file\n  ##  List of all items (files)\n  myItems.ALL <- as.vector(unique(files2process))\n  # create log file for processing results of items\n  #myItems.Log <- data.frame(cbind(myItems.ALL,NA),stringsAsFactors=FALSE)\n  myItems.Log <- data.frame(ItemID=1:intItems.Total,Status=NA,ItemName=myItems.ALL)\n  #\n\n\n  # Error if no files to process or no files in dir\n\n\n  # Start Time (used to determine run time at end)\n  myTime.Start <- Sys.time()\n\n  # Perform a data manipulation on the data as a new file\n  # Could use for (n in files2process) but prefer the control of a counter\n\n  while (intCounter < intCounter.Stop)\n  {\n    #\n    # 0. Increase the Counter\n    intCounter <- intCounter+1\n    #\n    # 1.0. File Name, Define\n    strFile = files2process[intCounter]\n    # 1.1. File Name, Parse\n    strFile.Base <- substr(strFile,1,nchar(strFile)-nchar(\".csv\"))\n    strFile.parts <- strsplit(strFile.Base,config.FileName.Delimiter)\n    strFile.SiteID     <- strFile.parts[[1]][2]\n    strFile.DataType   <- strFile.parts[[1]][3]\n\n    # Convert Data Type to proper case\n    strFile.DataType <- paste(toupper(substring(strFile.DataType,1,1)),tolower(substring(strFile.DataType,2,nchar(strFile.DataType))),sep=\"\")\n    strFile.Date.Start <- as.Date(strFile.parts[[1]][4],\"%Y%m%d\")\n    strFile.Date.End   <- as.Date(strFile.parts[[1]][5],\"%Y%m%d\")\n    #\n    # 2. Check File and skip if doesn't match user defined parameters\n    #\n    # check vs. previous SiteID\n    # if not the same (i.e., False) then reset the FileTypeNum Counters, will create new blank data.append\n    if((strFile.SiteID==strFile.SiteID.Previous)!=TRUE){##IF.SiteID.START\n      myFileTypeNum.Air <- 0\n      myFileTypeNum.Water <- 0\n      myFileTypeNum.AW <- 0\n      myFileTypeNum.Gage <- 0\n      myFileTypeNum.AWG <- 0\n      myFileTypeNum.AG <- 0\n      myFileTypeNum.WG <- 0\n    }##IF.SiteID.END\n    #str  #code fragment, 20160418\n    #\n    # 2.1. Check File Size\n    if(file.info(paste(myDir.data.import,\"/\",strFile,sep=\"\"))$size==0){\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (file blank)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n      next\n    }\n    # 2.2. Check SiteID\n    # if not in provided site list then skip\n    if(strFile.SiteID %in% fun.myData.SiteID == FALSE) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, SiteID)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n      next\n    }\n    # 2.3. Check DataType\n    # if not equal go to next file (handles both Air and Water)\n    if (strFile.DataType %in% fun.myData.Type == FALSE){\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, DataType)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n      next\n    }\n    # 2.4. Check Dates\n    # 2.4.2.1. Check File.Date.Start (if file end < my Start then next)\n    if(strFile.Date.End<fun.myData.DateRange.Start) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, Start Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n      next\n    }\n    # 2.4.2.2. Check File.Date.End (if file Start > my End then next)\n    if(strFile.Date.Start>fun.myData.DateRange.End) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, End Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n      next\n    }\n\n    myMsg <- \"STARTING\"\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.write.log(myItems.Log,myDate,myTime)\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n\n\n    #\n    # 3.0. Import the data\n    #data.import=read.table(strFile,header=F,varSep)\n    #varSep = \"\\t\" (use read.delim instead of read.table)\n    # as.is = T so dates come in as text rather than factor\n    #data.import <- read.delim(strFile,as.is=TRUE,na.strings=\"\")\n    data.import <- read.csv(paste(myDir.data.import,strFile,sep=\"/\"),as.is=TRUE,na.strings=\"\")\n    #\n    # QC required fields: SiteID & (DateTime | (Date & Time))\n    fun.helper.CheckRequiredFields(names(data.import),paste(myDir.data.import,strFile,sep=\"/\"))\n    #\n    #\n    #\n    # 4 and 5, skip\n    #\n    #\n    # QC date and time\n    # accessing files with Excel can change formats\n    # 20170116, EWL\n    data.import <- fun.QC.datetime(data.import)\n\n\n\n    ######################################\n    # filter data, append (if necessary), then export\n    ######################################\n\n    # 6.0. Filter data based on Date Range\n    ## \"subset\" can have issues.  \"with\" doesn't seem work using variables for colnames.\n    data.subset <- data.import[data.import[,myName.Date]>=fun.myData.DateRange.Start\n                               & data.import[,myName.Date]<=fun.myData.DateRange.End,]\n    #\n    # 7.0. Append Data\n    # Append different based on the DataType\n    # if all Air or all Water \"rbind\" is fine\n    # Define data.append as blank so can always rbind even if the first file\n    # but have to switch up if this is the first of either type\n    # files alphabetical so will get all Air then all Water files.\n    #\n    # 7.1. Record number of Air or Water files have worked on\n    # (set as zero before loop)\n    if(strFile.DataType==\"Air\"){myFileTypeNum.Air <- myFileTypeNum.Air + 1}\n    if(strFile.DataType==\"Water\"){myFileTypeNum.Water <- myFileTypeNum.Water + 1}\n    if(strFile.DataType==\"Aw\"){myFileTypeNum.AW <- myFileTypeNum.AW + 1}\n    if(strFile.DataType==\"Gage\"){myFileTypeNum.Gage <- myFileTypeNum.Gage +1}\n    if(strFile.DataType==\"AwG\"){myFileTypeNum.AW <- myFileTypeNum.AW + 1}\n    if(strFile.DataType==\"AG\"){myFileTypeNum.AW <- myFileTypeNum.AW + 1}\n    if(strFile.DataType==\"WG\"){myFileTypeNum.AW <- myFileTypeNum.AW + 1}\n    #\n    # 7.2. If 1st file of either type then create empty data.Append\n    if(strFile.DataType==\"Air\" & myFileTypeNum.Air==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"Water\" & myFileTypeNum.Water==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"Aw\" & myFileTypeNum.AW==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"Gage\" & myFileTypeNum.Gage==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"AWG\" & myFileTypeNum.AWG==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"AG\" & myFileTypeNum.AG==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    if(strFile.DataType==\"WG\" & myFileTypeNum.WG==1) {\n      # Create empty data frame for Append file\n      data.append <- data.frame(matrix(nrow=0,ncol=ncol(data.subset)))\n      names(data.append) <- names(data.subset)\n    }\n    #\n    # 7.3. Append Subset to Append\n    #data.append <- rbind(data.append,data.subset)\n    # change to merge\n    data.append <- merge(data.append,data.subset,all=TRUE,sort=FALSE)\n    #\n    # 8.0. Output file (only works if DataType is Air OR Water not both)\n    # 8.1. Set Name\n    File.Date.Start <- format(as.Date(fun.myData.DateRange.Start,myFormat.Date),\"%Y%m%d\")\n    File.Date.End   <- format(as.Date(fun.myData.DateRange.End,myFormat.Date),\"%Y%m%d\")\n    strFile.Out.Prefix <- \"DATA\"\n    strFile.Out <- paste(paste(strFile.Out.Prefix,strFile.SiteID,strFile.DataType,File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n    # 8.2. Save to File the Append data (overwrites any existing file).\n    #strFile.Out\n    #   varSep <- \"\\t\" #tab-delimited\n    #   write.table(data.append,file=strFile.Out,sep=varSep,quote=FALSE,row.names=FALSE,col.names=TRUE)\n    #print(paste(\"Saving output of file \",intCounter,\" of \",intCounter.Stop,\" files complete.\",sep=\"\"))\n    #flush.console()\n    write.csv(data.append,file=paste(myDir.data.export,\"/\",strFile.Out,sep=\"\"),quote=FALSE,row.names=FALSE)\n    # saves but if gets another one in the time range it will append as append is recycled between loop iterations\n    # when gets a new data type it gets a new data.append\n    # need trigger for different SiteID (won't combine across sites)\n\n\n    ##################\n    # insert QC Report so runs without user intervention\n    ##################\n    # run with same import and export directory & on new file\n    ###\n    # will run repeatedly for each subfile when aggregating\n\n\n    fun.Report(strFile.SiteID\n                 ,strFile.DataType\n                 ,fun.myData.DateRange.Start\n                 ,fun.myData.DateRange.End\n                 ,fun.myDir.SUB.export\n                 ,fun.myDir.SUB.export\n                 ,\"DATA\")\n\n    # 9. Clean up\n    # set previous SiteID for QC check near top\n    strFile.SiteID.Previous <- strFile.SiteID\n    # 9.1. Inform user of progress and update LOG\n    myMsg <- \"COMPLETE\"\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.write.log(myItems.Log,myDate,myTime)\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    # 9.2. Remove data (import and subset)\n    rm(data.import, data.subset)\n    #\n  }##while.END\n  #######################################################################\n\n\n\n  #\n  print(paste(\"Processing of \",intCounter,\" of \",intCounter.Stop,\" files complete.\",sep=\"\"))\n  files2process[intCounter] #use for troubleshooting if get error\n  # inform user task complete with status\n  myTime.End <- Sys.time()\n  print(paste(\"Processing of items (n=\",intItems.Total,\") finished.  Total time = \",format(difftime(myTime.End,myTime.Start)),\".\",sep=\"\"))\n  print(paste(\"Items COMPLETE = \",myItems.Complete,\".\",sep=\"\"))\n  print(paste(\"Items SKIPPPED = \",myItems.Skipped,\".\",sep=\"\"))\n  # User defined parameters\n  print(paste(\"User defined parameters: SiteID (\",fun.myData.SiteID,\"), Data Type (\",fun.myData.Type,\"), Date Range (\",fun.myData.DateRange.Start,\" to \",fun.myData.DateRange.End,\").\",sep=\"\"))\n  flush.console()\n\n\n  ### may have to move to inside of loop (original code for single SiteID)\n\n\n\n\n\n  # QC\n#   fun.myPrefix.merge <- myPrefix.merge\n#   fun.Name.myDF.1 <- myDF.Name.1\n#   fun.Name.myDF.2 <- myDF.Name.2\n\n\n\n\n\n  # Need to deal with overlapping data fields (gage and others) (merge only)\n  fun.merge <- function(fun.myPrefix.merge, fun.Name.myDF.1, fun.Name.myDF.2){##FUNCTION.fun.merge.START\n    #\n    #     # QC\n    #     fun.myPrefix.merge <- myPrefix.merge\n    #     fun.Name.myDF.1    <- myDF.Name.1\n    #     fun.Name.myDF.2    <- myDF.Name.2\n    #\n    # Load Files\n    data.DF.1 <- read.csv(paste(myDir.data.export,fun.Name.myDF.1,sep=\"/\"),as.is=TRUE,na.strings=\"\")\n    data.DF.2 <- read.csv(paste(myDir.data.export,fun.Name.myDF.2,sep=\"/\"),as.is=TRUE,na.strings=\"\")\n    #\n    # strip non file specific columns ????\n    # drop overlapping field names in data.DF.2 (typically the gage file) but keep DateTime\n    names.match <- names(data.DF.2) %in% names(data.DF.1)\n    data.DF.2.mod <- data.DF.2[,c(myName.DateTime,names(data.DF.2)[names.match==FALSE])]\n    # merge 1 and 2.mod\n    data.merge <- merge(data.DF.1,data.DF.2.mod,by=myName.DateTime,all=TRUE,sort=FALSE,suffixes=\"\")\n    #\n    # reapply some fields since the merge as some files have differen number of rows and purged duplicate fields\n    # Date, Time, month, day (bring from fun.QC.R, change data.import to data.merge)\n    # 5.2.2. Update Date if NA (use Date_Time)\n    myField   <- myName.Date\n    myFormat  <- myFormat.Date #\"%Y-%m-%d\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Date]==\"\"]\n    #                                                               ,format=myFormat,usetz=FALSE)\n    data.merge[,myField][is.na(data.merge[,myField])] <- strftime(data.merge[,myName.DateTime][is.na(data.merge[,myField])]\n                                                                  ,format=myFormat,usetz=FALSE)\n    # 5.2.3. Update Time if NA (use Date_Time)\n    myField   <- myName.Time\n    myFormat  <- myFormat.Time #\"%H:%M:%S\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Time]==\"\"]\n    #                                                               ,format=myFormat,usetz=FALSE)\n    #     data.merge[,myField][is.na(data.merge[,myField])] <- as.POSIXct(data.merge[,myName.DateTime][is.na(data.merge[,myField])]\n    #                                                                      ,format=myFormat,usetz=FALSE)\n    # update all time fields\n    data.merge[,myField] <- strftime(as.POSIXct(data.merge[,myName.DateTime],format=myFormat.DateTime,usetz=FALSE)\n                                     ,format=myFormat.Time,usetz=FALSE)\n    #\n    #\n    data.merge[,\"month\"] <- as.POSIXlt(data.merge[,myName.Date])$mon+1\n    data.merge[,\"day\"] <- as.POSIXlt(data.merge[,myName.Date])$mday\n    # update SiteID\n    data.merge[,myName.SiteID][is.na(data.merge[,myName.SiteID])] <- fun.myData.SiteID\n\n    # sort\n    # not working in merge command\n    data.merge <- data.merge[order(data.merge[,myName.DateTime]),,drop=FALSE]\n\n\n    # save file\n    #File.Date.Start <- format(as.Date(fun.myData.DateRange.Start,myFormat.Date),\"%Y%m%d\")\n    #File.Date.End   <- format(as.Date(fun.myData.DateRange.End,myFormat.Date),\"%Y%m%d\")\n    strFile.Out <- paste(myDir.data.export,paste(paste(\"DATA\",fun.myData.SiteID,fun.myPrefix.merge,File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\"),sep=\"/\")\n    write.csv(data.merge,file=strFile.Out,quote=FALSE,row.names=FALSE)\n    # QC report (fails on render - lines 41-83 in rmd)\n    #\n\n    fun.Report(fun.myData.SiteID\n                 ,fun.myPrefix.merge\n                 ,fun.myData.DateRange.Start\n                 ,fun.myData.DateRange.End\n                 ,fun.myDir.SUB.export\n                 ,fun.myDir.SUB.export\n                 ,\"DATA\")\n    # inform user\n    print(paste(\"Done merging \",fun.myPrefix.merge,\" files; \",strFile.Out,sep=\"\"))\n    flush.console()\n    # remove files\n    rm(data.DF.1)\n    rm(data.DF.2)\n    #rm(data.merge)\n    #\n    # plot\n    data.plot <- data.merge\n\n    # clean up\n    rm(data.merge)\n    #\n    rm(data.plot)\n\n  }##FUNCTION.fun.merge.END\n  #\n\n\n\n\n\n\n\n\n  File.Date.Start <- strftime(as.Date(fun.myData.DateRange.Start,\"%Y-%m-%d\"),\"%Y%m%d\")\n  File.Date.End   <- strftime(as.Date(fun.myData.DateRange.End,\"%Y-%m-%d\"),\"%Y%m%d\")\n\n\n\n  # have counters so can keep track of files\n\n  # myData.Type\n  # strFile.DataType\n  # myFileTypeNum.Air\n  # myFileTypeNum.Water\n  #\n  #\n  # DATA_Air_HRCC_20130101_20131231.csv\n  # DATA_Water_HRCC_20130101_20131231.csv\n  #\n  # List both files\n  #\n  # merge and save as BOTH (AW)\n  #\n  # paste(paste(\"DATA\",strFile.DataType,myData.SiteID,File.Date.Start,File.Date.End,sep=\"_\"),\"csv\",sep=\".\")\n\n\n  # Check for all Data Type  files (Air, Water, AW, Gage, AWG, AG, WG)\n  # had been using \"proper\" to get \"Air\" and \"Water\".  So AWG=Awg, AW=Aw, AG=Ag, and WG=Wg\n  # 1\n  Name.File.Air <- paste(paste(\"DATA\",fun.myData.SiteID,\"Air\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 2\n  Name.File.Water <- paste(paste(\"DATA\",fun.myData.SiteID,\"Water\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 3\n  Name.File.AW <- paste(paste(\"DATA\",fun.myData.SiteID,\"Aw\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 4\n  Name.File.Gage <- paste(paste(\"DATA\",fun.myData.SiteID,\"Gage\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 5\n  Name.File.AWG <- paste(paste(\"DATA\",fun.myData.SiteID,\"Awg\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 6\n  Name.File.AG <- paste(paste(\"DATA\",fun.myData.SiteID,\"Ag\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  # 7\n  Name.File.WG <- paste(paste(\"DATA\",fun.myData.SiteID,\"Wg\",File.Date.Start,File.Date.End,sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n  #\n  #\n  files.ALL <- list.files(path=myDir.data.export, pattern=\" *.csv\")\n  files.mine <- c(Name.File.Air,Name.File.Water,Name.File.AW,Name.File.Gage,Name.File.AWG,Name.File.AG,Name.File.WG)\n  files.match <- files.mine %in% files.ALL # will be length 7 (length of files.mine)\n  files.match.num <- sum(files.match==TRUE)\n  #\n  # only continue if have more than one.\n\n\n\n  ###### 20160418\n  # manual combination of A/W/G (auto not working properly depending on sequence)\n  #  fun.myData.Type\n\n  if(fun.myData.Type==\"Aw\"){\n    # Files = 1Air & 2Water = 3AW\n    if(files.match[1]==TRUE & files.match[2]==TRUE & files.match[3]==FALSE){##IF.files.AW.START\n      #\n      myPrefix.merge <- \"Aw\"\n      myDF.Name.1 <- Name.File.Air\n      myDF.Name.2 <- Name.File.Water\n      # run merge function\n      fun.merge(myPrefix.merge,myDF.Name.1,myDF.Name.2)\n      # mark file complete\n      myItems.Complete <- myItems.Complete + 1\n      #\n    }##IF.files.WG.END\n  }\n  #\n  if (fun.myData.Type==\"Ag\"){\n    # Files = 1Air & 4Gage = 6AG\n    if(files.match[1]==TRUE & files.match[4]==TRUE & files.match[6]==FALSE){##IF.files.AG.START\n      #\n      myPrefix.merge <- \"Ag\"\n      myDF.Name.1 <- Name.File.Air\n      myDF.Name.2 <- Name.File.Gage\n      # run merge function\n      fun.merge(myPrefix.merge,myDF.Name.1,myDF.Name.2)\n      # mark file complete\n      myItems.Complete <- myItems.Complete + 1\n      #\n    }##IF.files.AG.END\n  }\n  #\n  if (fun.myData.Type==\"Awg\"){\n    # Files = 3AW & 4Gage = 5AWG\n    if(files.match[3]==TRUE & files.match[4]==TRUE & files.match[5]==FALSE){##IF.files.AWG.START\n      # Run Merge Twice (but AW already took care of 1st merge)\n      # Merge 2\n      myPrefix.merge <- \"Awg\"\n      myDF.Name.1 <- Name.File.AW\n      myDF.Name.2 <- Name.File.Gage\n      # run merge function\n      fun.merge(myPrefix.merge,myDF.Name.1,myDF.Name.2)\n      # mark file complete\n      myItems.Complete <- myItems.Complete + 1\n      #\n    }##IF.files.AWG.END\n  }\n  #\n  if(fun.myData.Type==\"Wg\"){\n    # Files = 2Water & 4Gage = 7WG\n    if(files.match[2]==TRUE & files.match[4]==TRUE & files.match[7]==FALSE){\n      #\n      myPrefix.merge <- \"Wg\"\n      myDF.Name.1 <- Name.File.Water\n      myDF.Name.2 <- Name.File.Gage\n      # run merge function\n      fun.merge(myPrefix.merge,myDF.Name.1,myDF.Name.2)\n      # mark file complete\n      myItems.Complete <- myItems.Complete + 1\n      #\n    }\n  }\n  #\n\n\n\n  # 20151202\n  # Quit if skipped = total\n  if(myItems.Complete==0){\n    myMsg <- \"No files with the selected attributes available to perform selected procedure.  Check to make sure there are files that match your inputs (SiteID, DataType, and Date Range).  [This is a specific error message not an R error message].\"\n    stop(myMsg)\n  }\n\n\n  # trigger above should have caught if zero files and ended there\n  if (files.match.num==1){##IF.files.match.num.START\n    myMsg <- \"No other data type files exist for this SiteID and Date Range.  No combining across data types is possible.\"\n    # may want to continue so don't end\n    print(myMsg) #stop(myMsg)\n  } else { #should be if >1\n    myMsg <- \"Files for multiple data types exist for this SiteID and Date Range.  These will be be combined:\"\n    # list out below\n    print(myMsg)\n    print(files.mine[files.match==TRUE])\n  }\n\n    flush.console()\n\n  return()\n}\n\n\n\n",
    "created" : 1489080789996.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "501922210",
    "id" : "C00B418E",
    "lastKnownWriteTime" : 1489080800,
    "last_content_update" : 1489080800170,
    "path" : "~/tn_realtime/working/R_scripts/libs/fun.AggregateData.R",
    "project_path" : "libs/fun.AggregateData.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}