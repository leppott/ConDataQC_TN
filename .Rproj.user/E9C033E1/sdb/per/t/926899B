{
    "collab_server" : "",
    "contents" : "#!/cygdrive/c/Program Files/R/R-3.3.2patched/bin/R\n\n##################\n#\n# Quality Control\n#\n##################\n# Erik.Leppo@tetratech.com (EWL)\n#################\n#\n# assumes use of CSV.  If using TXT have to modify list.files(pattern), read.csv(), and write.csv()\n#\n# Basic Operations:\n# load all files in data directory\n# perform QC\n# write QC report\n# save QCed data file\n\n\n# 20160208\n# WaterLevel - Gross is only negative, Flat = remove\n# 20160303\n# Rolling SD.  Use \"zoo\" and rollapply.  Loop too slow for large/dense data sets.\n# (will crash if less than 5 records so added \"stop\")\n\n#\nlibrary(zoo, quietly = TRUE, warn.conflicts = FALSE)\nlibrary(futile.logger)\n\nfun.QC <- function(fun.myData.SiteID\n                   ,fun.myData.Type\n                   ,fun.myData.DateRange.Start\n                   ,fun.myData.DateRange.End\n                   ,fun.myDir.SUB.import\n                   ,fun.myDir.SUB.export) {\n  #\n  # Convert Data Type to proper case\n\n  #fun.myData.Type <- fun.CamelCase(fun.myData.Type)\n\n  #\n  # data directories\n  myDir.data.import <- fun.myDir.SUB.import\n  myDir.data.export <- fun.myDir.SUB.export\n\n  #\n  myDate <- format(Sys.Date(),\"%Y%m%d\")\n  myTime <- format(Sys.time(),\"%H%M%S\")\n\n  # Verify input dates, if blank, NA, or null use all data\n  # if DateRange.Start is null or \"\" then assign it 1900-01-01\n  if (is.na(fun.myData.DateRange.Start) == TRUE || fun.myData.DateRange.Start==\"\")\n  {\n    fun.myData.DateRange.Start <- DateRange.Start.Default\n  }\n\n  # if DateRange.End is null or \"\" then assign it today\n  if (is.na(fun.myData.DateRange.End)==TRUE || fun.myData.DateRange.End==\"\")\n  {\n    fun.myData.DateRange.End <- DateRange.End.Default\n  }\n\n  # Read in list of files to work on, uses all files matching pattern (\"\\\\.csv$\")\n  # ## if change formats will have to make modifications (pattern, import, export)\n  filename_pattern = \".+_\\\\d{8}_\\\\d{8}-\\\\d{8}-\\\\d{6}.csv$\"\n  filename_pattern = \".+_\\\\d{8}_\\\\d{8}.csv$\"\n  all_files = list.files(path=myDir.data.import) # , pattern=filename_pattern)\n  print(paste0('match filename_pattern==', paste(all_files, collapse = ',')))\n  # only interested in files if they have the SiteID and Type in the filename\n  site_files <- grep(fun.myData.SiteID, all_files, value = TRUE)\n  print(paste0('match SiteID_pattern==', paste(site_files, collapse = ',')))\n  files2process <- grep(fun.myData.Type,   site_files, value = TRUE)\n  print(paste0('match data type_pattern==', paste(files2process, collapse = ',')))\n  print(paste(files2process, collapse = ','))\n\n  #\n  # Define Counters for the Loop\n  intCounter <- 0\n  intCounter.Stop <- length(files2process)\n  intItems.Total <- intCounter.Stop\n\n\n  if (intItems.Total == 0)\n  {\n    flog.debug(paste0(\"No files matching pattern \", filename_pattern, \" to process in folder\\n\\t\", myDir.data.import))\n    return()\n  }\n  flog.debug(paste0(\"Total files to process = \", intItems.Total))\n\n  myItems.Complete  <- 0\n  myItems.Skipped   <- 0\n  myFileTypeNum.Air <- 0\n  myFileTypeNum.Water <- 0\n\n  # Create Log file\n  ##  List of all items (files)\n  myItems.ALL <- as.vector(unique(files2process))\n\n  # create log file for processing results of items\n  #myItems.Log <- data.frame(cbind(myItems.ALL,NA),stringsAsFactors=FALSE)\n  myItems.Log <- data.frame(ItemID = 1:intItems.Total, Status = NA, ItemName = myItems.ALL)\n\n  # Error if no files to process or no files in dir\n\n  # Start Time (used to determine run time at end)\n  myTime.Start <- Sys.time()\n\n  # Perform a data manipulation on the data as a new file\n  # Could use for (n in files2process) but prefer the control of a counter\n  while (intCounter < intCounter.Stop)\n  {\n    #\n    # 0. Increase the Counter\n    intCounter <- intCounter + 1\n    #\n    # 1.0. File Name, Define\n    strFile = files2process[intCounter]\n\n    strFile.source.full_name = file.path(myDir.data.import,strFile)\n\n    #\n    # 2. Check File and skip if doesn't match user defined parameters\n    #\n    if(file.info( strFile.source.full_name )$size == 0)\n    {\n      flog.debug(paste0(\"File is empty (size 0 bytes).  Skipping...\\n\\t\",strFile.source.full_name))\n      next\n    }\n\n\n    flog.debug(paste0(\"Begin processing file\\n\\t\",strFile.source.full_name))\n\n\n    # 1.1. File Name, Parse\n    strFile.Base  <- substr(strFile,1,nchar(strFile)-nchar(\".csv\"))\n    strFile.parts <- strsplit(strFile.Base, config.FileName.Delimiter)\n\n    strFile.SiteID   <- strFile.parts[[1]][1]\n    strFile.DataType <- strFile.parts[[1]][2]\n\n    # Convert Data Type to Camel Case\n    # strFile.DataType <- fun.CamelCase(strFile.DataType)\n\n    strFile.Date.Start <- as.Date(strFile.parts[[1]][3],\"%Y%m%d\")\n    strFile.Date.End   <- as.Date(strFile.parts[[1]][4],\"%Y%m%d\")\n\n    # 2.2. Check SiteID\n    # if not in provided site list then skip\n    if(strFile.SiteID %in% fun.myData.SiteID == FALSE)\n    {\n      myMsg <- \"SKIPPED (Non-Match, SiteID)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    # 2.3. Check DataType\n    # if not equal go to next file (handles both Air and Water)\n    if (strFile.DataType %in% fun.myData.Type == FALSE)\n    {\n      myMsg <- \"SKIPPED (Non-Match, DataType)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    # 2.4. Check Dates\n    # 2.4.2.1. Check File.Date.Start (if file end < my Start then next)\n    if(strFile.Date.End<fun.myData.DateRange.Start)\n    {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, Start Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    # 2.4.2.2. Check File.Date.End (if file Start > my End then next)\n    if(strFile.Date.Start>fun.myData.DateRange.End) {\n\n      myMsg <- \"SKIPPED (Non-Match, End Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    #\n    # 3.0. Import the data\n    data.import <- read.csv( strFile.source.full_name, as.is=TRUE, na.strings=\"\", skip=1)\n\n    #\n    # QC required fields: SiteID & (DateTime | (Date & Time))\n    fun.helper.CheckRequiredFields( names(data.import), file.path(myDir.data.import, strFile))\n\n    #\n    # 4.0. Columns\n    # Kick out if missing minimum of fields\n    #\n    # Check for and add any missing columns (but not for missing data fields)\n    # 4.1. Date, Time, DateTime\n    # list\n    strCol.DT <- c(myName.Date, myName.Time, myName.DateTime)\n    # check for missing\n    strCol.DT.Missing <- strCol.DT[strCol.DT %in% colnames(data.import)==FALSE]\n    # go to next item if no date, time, or date/time field\n\n    if(length(strCol.DT.Missing) == 3)\n    {\n      myMsg <- \"SKIPPED (Missing Fields, Date/Time)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    # go to next item if no (date or time) AND no date/time field  (i.e., only 1 of date or time)\n    if(length(strCol.DT.Missing)==2 & myName.DateTime%in%strCol.DT.Missing==TRUE)\n    {\n      myMsg <- \"SKIPPED (Missing Fields, 'Date.Time' and one of 'Date' or 'Time')\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n\n      flush.console()\n      next\n    }\n    #\n    # add to df\n    data.import[,strCol.DT.Missing] <- NA\n    #\n    # 4.2.  Check for columns present and reorder columns\n    # check for columns present\n    strCol.Present <- myNames.Order[myNames.Order %in% colnames(data.import)==TRUE]\n    #\n    myNames.DataFields.Present <- myNames.DataFields[myNames.DataFields %in% colnames(data.import)==TRUE]\n\n    # kick out if no data fields\n    if(length(myNames.DataFields.Present)==0){\n      myMsg <- \"SKIPPED (Missing Fields, DATA)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n      flush.console()\n      # go to next Item\n    }\n    #\n    # reorder Columns (and drop extra columns)\n    data.import <- data.import[,strCol.Present]\n\n    # add column that will show if there are any flags in that row\n    data.import[,'FlagCount'] <- 0\n\n    # 4.3. Add FLAGS\n    strCol.Flags <- myNames.Flags[myNames.Cols4Flags %in% colnames(data.import)==TRUE]\n    data.import[, strCol.Flags] <- \"\"\n\n    #\n    # 5.  QC Date and Time fields\n    #\n\n    ##############\n    # get format - if all data NA then get an error\n    #\n    # backfill first?\n    #\n    # may have to add date and time (data) from above when add the missing field.\n    #if does not exists then add field and data.\n    #\n    # if entire field is NA then fill from other fields\n\n    # Date\n    myField   <- myName.Date\n    data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,myName.DateTime]\n\n    # Time\n    myField   <- myName.Time\n    data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,myName.DateTime]\n\n    # DateTime\n    #myField   <- myName.DateTime\n    # can't fill fill from others without knowing the format\n    #\n    # get current file date/time records so can set format\n    # Function below gets date or time format and returns R format\n    # date_time is split and then pasted together.\n    # if no AM/PM then 24hr time is assumed\n    format.Date     <- fun.DateTimeFormat(data.import[,myName.Date],\"Date\")\n    format.Time     <- fun.DateTimeFormat(data.import[,myName.Time],\"Time\")\n    #format.DateTime <- fun.DateTimeFormat(data.import[,myName.DateTime],\"DateTime\")\n    # get error if field is NA, need to fix\n    # same for section below\n    #\n    # 20160322, new section, check for NA and fill if needed\n    if (length(na.omit(data.import[,myName.DateTime]))==0){\n      # move 5.2.1 up here\n      myField   <- myName.DateTime\n      myFormat  <- pbcc.Format.Date # myFormat.DateTime # \"%Y-%m-%d %H:%M:%S\"\n      flog.debug(paste0('date format could be myFormat==', myFormat))\n\n      data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,myName.Date][is.na(data.import[,myField])]\n                                                                            ,data.import[,myName.Time][is.na(data.import[,myField])]\n                                                                            ,sep=\" \")\n                                                                      ,format=myFormat,usetz=FALSE)\n    }\n\n    format.DateTime <- fun.DateTimeFormat(data.import[,myName.DateTime],\"DateTime\")\n\n    # QC\n    #  # format.Date <- \"%Y-%m-%d\"\n    #   format.Time <- \"%H:%M:%S\"\n    #   format.DateTime <- \"%Y-%m-%d %H:%M\"\n    #\n    # 5. QC Date and Time\n    # 5.1. Convert all Date_Time, Date, and Time formats to expected format (ISO 8601)\n    # Should allow for users to use different time and date formats in original data\n    # almost worked\n    #data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime] <- strftime(data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime]\n    #                                                                                   ,format=\"%Y-%m-%d\")\n    # have to do where is NOT NA because will fail if the first item is NA\n    # assume all records have the same format.\n    #\n    # 5.1.1. Update Date to \"%Y-%m-%d\" (equivalent to %F)\n    myField   <- myName.Date\n    myFormat.In  <- format.Date #\"%Y-%m-%d\"\n    myFormat.Out <- myFormat.Date #\"%Y-%m-%d\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n    # 5.1.2. Update Time to \"%H:%M:%S\" (equivalent to %T) (uses different function)\n    myField   <- myName.Time\n    myFormat.In  <- format.Time #\"%H:%M:%S\"\n    myFormat.Out <- myFormat.Time #\"%H:%M:%S\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(as.POSIXct(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n    # 5.1.3. Update DateTime to \"%Y-%m-%d %H:%M:%S\" (equivalent to %F %T)\n    myField   <- myName.DateTime\n    myFormat.In  <- format.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    myFormat.Out <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n\n    #\n    # 5.2. Update DateTime, Date, and Time if NA based on other fields\n    # 5.2.1. Update Date_Time if NA (use Date and Time)\n    myField   <- myName.DateTime\n    myFormat  <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n\n    data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,myName.Date][is.na(data.import[,myField])]\n                                                                          ,data.import[,myName.Time][is.na(data.import[,myField])]\n                                                                          ,sep=\" \")\n                                                                    ,format=myFormat,usetz=FALSE)\n    # 5.2.2. Update Date if NA (use Date_Time)\n    myField   <- myName.Date\n    myFormat  <- myFormat.Date\n\n    data.import[,myField][is.na(data.import[,myField])] <- strftime(data.import[,myName.DateTime][is.na(data.import[,myField])]\n                                                                    ,format=myFormat,usetz=FALSE)\n    # 5.2.3. Update Time if NA (use Date_Time)\n    myField   <- myName.Time\n    myFormat  <- myFormat.Time\n\n    data.import[,myField][is.na(data.import[,myField])] <- as.POSIXct(data.import[,myName.DateTime][is.na(data.import[,myField])]\n                                                                      ,format=myFormat,usetz=FALSE)\n\n    # Create Month and Day Field\n    data.import[,\"month\"] <- as.POSIXlt(data.import$Date)$mon + 1\n    data.import[,\"day\"]   <- as.POSIXlt(data.import$Date)$mday\n\n    # 6. QC for each Data Type present\n    # sub routine adds QC Calcs, QC Test Flags, Assigns overall Flag, and removes QC Calc Fields\n    # cycle each data type (manually code)\n\n    #\n    # skip if not present\n    #\n    # 6.1. WaterTemp\n    myField <- myName.WaterTemp\n\n    if(myField %in% myNames.DataFields.Present == TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n\n      data.import <- fun.CalcQCStats(data.import\n                                     ,myField\n                                     ,myThresh.Gross.Fail.Hi.WaterTemp\n                                     ,myThresh.Gross.Fail.Lo.WaterTemp\n                                     ,myThresh.Gross.Suspect.Hi.WaterTemp\n                                     ,myThresh.Gross.Suspect.Lo.WaterTemp\n                                     ,myThresh.Spike.Hi.WaterTemp\n                                     ,myThresh.Spike.Lo.WaterTemp\n                                     ,myThresh.RoC.SD.period.WaterTemp\n                                     ,myThresh.RoC.SD.number.WaterTemp\n                                     ,myThresh.Flat.Hi.WaterTemp\n                                     ,myThresh.Flat.Lo.WaterTemp\n                                     ,myThresh.Flat.Tolerance.WaterTemp)\n    }\n\n    #\n    # 6.2. AirTemp\n    myField <- myName.AirTemp\n    if(myField %in% myNames.DataFields.Present==TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n      data.import <- fun.CalcQCStats(data.import\n                                  ,myField\n                                  ,myThresh.Gross.Fail.Hi.AirTemp\n                                  ,myThresh.Gross.Fail.Lo.AirTemp\n                                  ,myThresh.Gross.Suspect.Hi.AirTemp\n                                  ,myThresh.Gross.Suspect.Lo.AirTemp\n                                  ,myThresh.Spike.Hi.AirTemp\n                                  ,myThresh.Spike.Lo.AirTemp\n                                  ,myThresh.RoC.SD.period.AirTemp\n                                  ,myThresh.RoC.SD.number.AirTemp\n                                  ,myThresh.Flat.Hi.AirTemp\n                                  ,myThresh.Flat.Lo.AirTemp\n                                  ,myThresh.Flat.Tolerance.AirTemp)\n    }\n\n    #\n    # 6.3. WaterP\n    myField <- myName.WaterP\n\n    if(myField %in% myNames.DataFields.Present==TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n      data.import <- fun.CalcQCStats(data.import\n                                  ,myField\n                                  ,myThresh.Gross.Fail.Hi.WaterP\n                                  ,myThresh.Gross.Fail.Lo.WaterP\n                                  ,myThresh.Gross.Suspect.Hi.WaterP\n                                  ,myThresh.Gross.Suspect.Lo.WaterP\n                                  ,myThresh.Spike.Hi.WaterP\n                                  ,myThresh.Spike.Lo.WaterP\n                                  ,myThresh.RoC.SD.period.WaterP\n                                  ,myThresh.RoC.SD.number.WaterP\n                                  ,myThresh.Flat.Hi.WaterP\n                                  ,myThresh.Flat.Lo.WaterP\n                                  ,myThresh.Flat.Tolerance.WaterP)\n    }\n\n    # 6.4. AirBP\n    myField <- myName.AirBP\n\n    if(myField %in% myNames.DataFields.Present==TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n      data.import <- fun.CalcQCStats(data.import\n                                  ,myField\n                                  ,myThresh.Gross.Fail.Hi.AirBP\n                                  ,myThresh.Gross.Fail.Lo.AirBP\n                                  ,myThresh.Gross.Suspect.Hi.AirBP\n                                  ,myThresh.Gross.Suspect.Lo.AirBP\n                                  ,myThresh.Spike.Hi.AirBP\n                                  ,myThresh.Spike.Lo.AirBP\n                                  ,myThresh.RoC.SD.period.AirBP\n                                  ,myThresh.RoC.SD.number.AirBP\n                                  ,myThresh.Flat.Hi.AirBP\n                                  ,myThresh.Flat.Lo.AirBP\n                                  ,myThresh.Flat.Tolerance.AirBP)\n    }\n    #\n    # 6.5. WaterLevel\n    myField <- myName.WaterLevel\n\n    if(myField %in% myNames.DataFields.Present==TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n      data.import <- fun.CalcQCStats(data.import\n                                  ,myField\n                                  ,myThresh.Gross.Fail.Hi.WaterLevel\n                                  ,myThresh.Gross.Fail.Lo.WaterLevel\n                                  ,myThresh.Gross.Suspect.Hi.WaterLevel\n                                  ,myThresh.Gross.Suspect.Lo.WaterLevel\n                                  ,myThresh.Spike.Hi.WaterLevel\n                                  ,myThresh.Spike.Lo.WaterLevel\n                                  ,myThresh.RoC.SD.period.WaterLevel\n                                  ,myThresh.RoC.SD.number.WaterLevel\n                                  ,myThresh.Flat.Hi.WaterLevel\n                                  ,myThresh.Flat.Lo.WaterLevel\n                                  ,myThresh.Flat.Tolerance.WaterLevel)\n      #\n    }\n    #\n    # 6.5. Discharge\n    myField <- myName.Discharge\n\n    if(myField %in% myNames.DataFields.Present==TRUE)\n    {\n      flog.debug(paste0('Processing data for ', myField))\n\n      data.import <- fun.CalcQCStats(data.import\n                                     ,myField\n                                     ,myThresh.Gross.Fail.Hi.Discharge\n                                     ,myThresh.Gross.Fail.Lo.Discharge\n                                     ,myThresh.Gross.Suspect.Hi.Discharge\n                                     ,myThresh.Gross.Suspect.Lo.Discharge\n                                     ,myThresh.Spike.Hi.Discharge\n                                     ,myThresh.Spike.Lo.Discharge\n                                     ,myThresh.RoC.SD.period.Discharge\n                                     ,myThresh.RoC.SD.number.Discharge\n                                     ,myThresh.Flat.Hi.Discharge\n                                     ,myThresh.Flat.Lo.Discharge\n                                     ,myThresh.Flat.Tolerance.Discharge)\n    }\n\n    #############################\n    #\n    # Names of columns for QC Calculations and Tests with Flags for each data column present\n    # combine so can check for and remove later.\n\n    myNames.DataFields.Present.QCCalcs   <- as.vector(t(outer(myNames.DataFields.Present,myNames.QCCalcs,paste,sep=\".\")))\n\n    myNames.Flags.QCTests <- paste0(\"Flag.\",as.vector(t(outer( myNames.QCTests, myNames.DataFields.Present, paste, sep=\".\"))))\n\n    #jab removed for now - I don't see them being used\n    #\n    # myNames.DataFields.Present <- myNames.DataFields[myNames.DataFields %in% colnames(data.import)==TRUE]\n    # # add Date.Time to names for modification\n    # myNames.DataFields2Mod <- c(myName.DateTime, myNames.DataFields.Present)\n    # #\n    # # 5.0. Add \"RAW\" and \"Comment.MOD\" fields\n    # # default values\n    # myName.Raw <- \"RAW\"\n    # myName.Comment.Mod <- \"Comment.MOD\"\n    #\n    # # 5.1. Cycle each present field\n    # for (j in myNames.DataFields2Mod) {\n    #\n    #   # A. Add comment field and leave blank\n    #   data.import[,paste(myName.Comment.Mod,j,sep=\".\")] <- \"\"\n    #\n    #   # B. Add data.RAW and populate with original data\n    #   data.import[,paste(myName.Raw,j,sep=\".\")] <- data.import[,j]\n    # }\n\n    ###########################\n    #\n    # create a CSV file that is used by the QC Report function\n    #\n    ###############\n\n    File.Date.Start <- format(as.Date(strFile.Date.Start, myFormat.Date),\"%Y%m%d\")\n    File.Date.End   <- format(as.Date(strFile.Date.End, myFormat.Date),\"%Y%m%d\")\n\n    strFile.Out.Prefix <- \"QC\"\n\n    strFile.Out <- paste(paste(strFile.Out.Prefix,\n                               strFile.SiteID,\n                               strFile.DataType,\n                               File.Date.Start,\n                               File.Date.End, sep=config.FileName.Delimiter),\"csv\",sep=\".\")\n\n    strFile.full_name = file.path(myDir.data.export,strFile.Out)\n\n    # 10.2. Save to File the data (overwrites any existing file).\n\n    write.csv(data.import, file=strFile.full_name, quote=FALSE, row.names=FALSE)\n    #\n    # flog.debug(paste0('Wrote CSV file' , \"\\n\\t\", strFile.full_name))\n\n    ##################\n    #\n    # Run QC Report\n    #\n    ####################\n\n    fun.Report(strFile.SiteID\n                 ,strFile.DataType\n                 ,strFile.Date.Start\n                 ,strFile.Date.End\n                 ,fun.myDir.SUB.export\n                 ,fun.myDir.SUB.export\n                 ,strFile.Out.Prefix)\n\n\n    ##################\n    #\n    # Format final CSV file\n    #\n    ####################\n\n    # remove all the 'P' (passing) flags from each Flag.* column just to simplify the CSV file\n    #\n    for(j in names(data.import))\n    {\n      column_name_parts <- strsplit(j, '[.]')\n\n      if (column_name_parts[[1]][1] == 'Flag')\n      {\n        data.import[,j][data.import[,j]==\"P\"] <- \"\"\n      }\n    }\n\n    # set the 'FlagCount' values to the sum of Flag columns that have something other than 'P' in them\n    #\n    data.import$FlagCount <- rowSums(data.import[, strCol.Flags] != \"\")\n\n    # remove columns that are entirely empty\n    #\n    data.import <- data.import[, ! apply(data.import, 2, function(x) all(gsub(\" \", \"\", x)==\"\", na.rm=TRUE))]\n\n    # remove some redundant columns to simplify the CSV file\n    #\n    remove_columns = c('day', 'month', 'Date', 'Time')\n    data.import <- data.import[, ! names(data.import) %in% remove_columns, drop = F]\n\n    # write the csv file in its final format\n    #\n    write.csv(data.import, file=strFile.full_name, quote=FALSE, row.names=FALSE)\n\n    #\n    flog.debug(paste0('Wrote CSV file again' , \"\\n\\t\", strFile.full_name))\n\n    # 11. Clean up\n    # 11.1. Inform user of progress and update LOG\n    myMsg <- \"COMPLETE\"\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.write.log(myItems.Log,myDate,myTime)\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n\n    flog.debug(paste0('Finished processing file' , \"\\n\\t\", strFile.source.full_name))\n\n    # 11.2. Remove data (import)\n    rm(data.import)\n  }\n\n  # print a message and return\n  flog.debug(paste(\"Task COMPLETE; \",round(difftime(Sys.time(),myTime.Start,units=\"mins\"),2),\" min.\",sep=\"\"))\n\n  return()\n}\n\n######################################################################\n\n\n########################\n# FUNCTION\n########################\n# Generate QC Test Calculations, QC Test Flags, and Assign overall flags\n# input is a single data field and the thresholds\n# output is a data frame (assumes data.import)\n# reuses items from this script and calling script.  Not a stand alone function\n#\nfun.CalcQCStats <- function(fun.data.import\n                            ,fun.myField.Data\n                            ,fun.myThresh.Gross.Fail.Hi\n                            ,fun.myThresh.Gross.Fail.Lo\n                            ,fun.myThresh.Gross.Suspect.Hi\n                            ,fun.myThresh.Gross.Suspect.Lo\n                            ,fun.myThresh.Spike.Hi\n                            ,fun.myThresh.Spike.Lo\n                            ,fun.myThresh.RoC.SD.period\n                            ,fun.myThresh.RoC.SD.number\n                            ,fun.myThresh.Flat.Hi\n                            ,fun.myThresh.Flat.Lo\n                            ,fun.myThresh.Flat.Tolerance) {\n\n  # A.1. Calc, SD Time Interval\n  myCalc <- \"SD.Time\"\n\n  myField <- paste(fun.myField.Data, myCalc, sep = \".\")\n\n  # calculate as separate variable\n  #http://stackoverflow.com/questions/8857287/how-to-add-subtract-time-from-a-posixlt-time-while-keeping-its-class-in-r\n  # myT will be a POSIXt object\n  myT <- strptime(fun.data.import[,myName.DateTime],format=myFormat.DateTime)\n\n  myT$hour <- myT$hour - fun.myThresh.RoC.SD.period\n\n  # add back to dataframe\n  fun.data.import[,myField] <- as.character(myT)\n\n  #\n  # variable for following block\n  myField.T1 <- myField\n\n  #\n  # A.2. Calc, SD, calc SD of last 25 hours\n  myCalc <- \"SD\"\n\n  myField <- paste(fun.myField.Data, myCalc, sep=\".\")\n\n  ###################################################\n  ## zoo version with rollapply\n  #  minimum of 5 records\n  if(nrow(fun.data.import) < 5)\n  {\n    stop(paste0(\"The data file has less than 5 records. The scripts will not work properly until you have more data.\"))\n  }\n\n  # get interval distance (will crash if less than 5 records)\n  myT.diff <- difftime(fun.data.import[5,myName.DateTime],fun.data.import[4,myName.DateTime],units=\"mins\")\n  myT.diff[[1]]\n\n  # convert DateTime to POSIX object (already done above)\n  #myT <- strptime(fun.data.import[,myName.DateTime],format=myFormat.DateTime)\n  # A.2. Use data \"as is\"\n  # create zoo object of data and date/time (use row num instead)\n  zoo.data <- zoo(fun.data.import[,fun.myField.Data], seq(from=1, to=nrow(fun.data.import), by=1))  # works\n  #\n  # B. Rolling SD\n  # time difference is in minutes and Threshold is in hours\n  # \"By\" in rollapply goes by # of records not by a set time.\n  RollBy <- fun.myThresh.RoC.SD.period/(myT.diff[[1]]/60)\n\n  # right align says the previous 50\n  # +1 is to include the record itself\n  RollSD <- rollapply(data=zoo.data, width=RollBy+1, FUN=sd, na.rm=TRUE, fill=NA, align=\"right\")\n  # add to data frame\n  fun.data.import[,myField] <- RollSD\n\n  # clean up\n  rm(myT)\n  rm(zoo.data)\n  rm(RollSD)\n\n# ###################################################\n\n  # A.3. Calc, NxSD, SD * n.per\n  myCalc.1 <- \"SD\"\n  myCalc.2 <- \"SDxN\"\n  myField.1 <- paste(fun.myField.Data,myCalc.1,sep=\".\")\n  myField.2 <- paste(fun.myField.Data,myCalc.2,sep=\".\")\n  fun.data.import[,myField.2] <- fun.data.import[,myField.1] * fun.myThresh.RoC.SD.number\n  #\n  # A.4. Calc, Diff (1:5) (5 is default but can be more)\n  for (i in 1:myThresh.Flat.MaxComp) {\n    myCalc <- paste(\"n\",i,sep=\".\")\n    myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n    fun.data.import[-(1:i),myField] <- diff(as.numeric(fun.data.import[,fun.myField.Data]),lag=i)\n    #\n  }\n\n  # A.5. Calc, flat.Hi, count n.1 etc if less than toler\n  myCalc <- \"flat.Hi\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  myThresh <- fun.myThresh.Flat.Hi\n  # Fields to check\n  myFields.Match <- match(paste(fun.myField.Data,\"n\",1:myThresh,sep=\".\"), names(fun.data.import))\n  # use rowSums to count the fields\n  fun.data.import[,myField] <- rowSums(abs(fun.data.import[,myFields.Match])<=fun.myThresh.Flat.Tolerance)\n\n  # A.6. Calc, flat.Lo, count if less than toler\n  myCalc <- \"flat.Lo\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  myThresh <- fun.myThresh.Flat.Lo\n  # Fields to check\n  myFields.Match <- match(paste(fun.myField.Data,\"n\",1:myThresh,sep=\".\"), names(fun.data.import))\n  # use rowSums to count the fields\n  fun.data.import[,myField] <- rowSums(abs(fun.data.import[,myFields.Match])<=fun.myThresh.Flat.Tolerance)\n\n  ## B. Generate Flags based on Calculation Fields\n  # B.1. Gross\n  myQCTest <- \"Gross\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- myFlagVal.NotEval\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- myFlagVal.NoData\n  # different test for water level, only if negative\n\n  if(fun.myField.Data==myName.WaterLevel)\n  {\n    # data < 0 (i.e., negative) = 4 (fail)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] < 0] <- myFlagVal.Fail\n    # otherwise flag = 1 (pass)\n    fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n  # different test for discharge\n  } else if(fun.myField.Data==myName.Discharge)\n  {\n    # data < 0 (i.e., negative) = 4 (fail)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] < 0] <- myFlagVal.Fail\n    # otherwise flag = 1 (pass)\n    fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n  } else\n  {\n    # data >= Suspect.Hi then flag = 3 (suspect)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] >= fun.myThresh.Gross.Suspect.Hi] <- myFlagVal.Suspect\n    # data <= Suspect.Lo then flag = 3 (Suspect)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] <= fun.myThresh.Gross.Suspect.Lo] <- myFlagVal.Suspect\n    # data >= Fail.Hi then flag = 4 (fail)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] >= fun.myThresh.Gross.Fail.Hi] <- myFlagVal.Fail\n    # data <= Fail.Lo then flag = 4 (fail)\n    fun.data.import[,myField][fun.data.import[,fun.myField.Data] <= fun.myThresh.Gross.Fail.Lo] <- myFlagVal.Fail\n    # otherwise flag = 1 (pass)\n    fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n  }\n\n  # B.2. Spike\n  myQCTest <- \"Spike\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"n\",1,sep=\".\")\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- myFlagVal.NotEval\n  # diff 1 is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,myField.Calc.1])==TRUE] <- myFlagVal.NoData\n  # abs(diff 1) >= spike Lo then flag = 3 (suspect)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) >= fun.myThresh.Spike.Lo] <- myFlagVal.Suspect\n  # abs(diff 1) >= spike Hi then flag = 4 (fail)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) >= fun.myThresh.Spike.Hi] <- myFlagVal.Fail\n  # otherwise flag = 1 (pass)\n  fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n\n  # B.3. RoC\n  myQCTest <- \"RoC\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"n\",1,sep=\".\")\n  myField.Calc.2 <- paste(fun.myField.Data,\"SDxN\",sep=\".\")\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- myFlagVal.NotEval\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- myFlagVal.NoData\n  # sd is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,myField.Calc.1])==TRUE] <- myFlagVal.NoData\n  # diff 1 > SD*N then flag = 3 (suspect)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) > fun.data.import[,myField.Calc.2]] <- myFlagVal.Suspect\n  # otherwise flag = 1 (pass) [no 4/Fail]\n  fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n\n  # B.4. Flat\n  myQCTest <- \"Flat\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"flat.Hi\",sep=\".\")\n  myField.Calc.2 <- paste(fun.myField.Data,\"flat.Lo\",sep=\".\")\n  # default value\n  fun.data.import[,myField] <- myFlagVal.NotEval\n  # Lo >= Thresh.Lo = 3 (suspect)\n  fun.data.import[,myField][fun.data.import[,myField.Calc.2] >= fun.myThresh.Flat.Lo] <- myFlagVal.Suspect\n  # Hi >= Thresh.Hi = 4 (fail)\n  fun.data.import[,myField][fun.data.import[,myField.Calc.1] >= fun.myThresh.Flat.Hi] <- myFlagVal.Fail\n  # otherwise flag = 1 (pass)\n  fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n\n  # C. Assign Overall Data Flag\n  myField <- paste(\"Flag\",fun.myField.Data,sep=\".\")\n\n  #myNames.QCTests\n  # get column numbers (match) for QCTest Flags for this data\n  myFields.Match <- match(paste(\"Flag\",myNames.QCTests,fun.myField.Data,sep=\".\"), names(fun.data.import))\n\n  # Conditional rowSums for number of flag fields with specified flags\n  myFlags.Num.Pass    <- rowSums(fun.data.import[,myFields.Match]==myFlagVal.Pass)\n  myFlags.Num.Suspect <- rowSums(fun.data.import[,myFields.Match]==myFlagVal.Suspect )\n  myFlags.Num.Fail    <- rowSums(fun.data.import[,myFields.Match]==myFlagVal.Fail)\n  myFlags.Num.Missing <- rowSums(fun.data.import[,myFields.Match]==myFlagVal.NoData)\n  myFlags.Num.OK      <- rowSums(fun.data.import[,myFields.Match]==myFlagVal.Pass | fun.data.import[,myFields.Match]==myFlagVal.NoData)\n\n  # Assign\n  # default value\n  fun.data.import[,myField] <- myFlagVal.NotEval\n  # any QC Test flags = 3 then flag = 3 (suspect)\n  fun.data.import[,myField][myFlags.Num.Suspect > 0] <- myFlagVal.Suspect\n  # any QC Test flags = 4 then flag = 4 (fail)\n  fun.data.import[,myField][myFlags.Num.Fail > 0] <- myFlagVal.Fail\n  # all QC Test flags = 1 then flag = 1 (pass)\n  fun.data.import[,myField][myFlags.Num.Pass == length(myNames.QCTests)] <- myFlagVal.Pass\n  # all QC Test flags = 1 or 9 then flag = 1 (pass)\n  fun.data.import[,myField][myFlags.Num.OK == length(myNames.QCTests)] <- myFlagVal.Pass\n    #fun.data.import[,myField][fun.data.import[,myField]==myFlagVal.NotEval] <- myFlagVal.Pass\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- myFlagVal.NoData\n\n  # D. Remove QC Calc fields\n  #myNames.QCCalcs <- c(\"SD.Time\",\"SD\",\"SDxN\",\"n.1\",\"n.2\",\"n.3\",\"n.4\",\"n.5\",\"flat.Lo\",\"flat.Hi\")\n  # get field column numbers\n  myFields.Match <- match(paste(fun.myField.Data,myNames.QCCalcs,sep=\".\"), names(fun.data.import))\n  # drop fields from data table\n  fun.data.import <- fun.data.import[,-na.omit(myFields.Match)]\n\n  # function output\n  return(fun.data.import)\n}\n\n\n",
    "created" : 1488990536999.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3019125783",
    "id" : "926899B",
    "lastKnownWriteTime" : 1490715146,
    "last_content_update" : 1490715146331,
    "path" : "~/tn_realtime/working/R_scripts/libs/fun.QC.R",
    "project_path" : "libs/fun.QC.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}