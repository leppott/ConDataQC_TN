{
    "collab_server" : "",
    "contents" : "# Sourced Routine\n##################\n# Quality Control (auto)\n#########################\n# make user script smaller and easier to understand\n# not a true function, needs defined variables in calling script\n# if change variable names in either file have to update the other\n##################\n# Erik.Leppo@tetratech.com (EWL)\n# 20150921\n##################\n# assumes use of CSV.  If using TXT have to modify list.files(pattern), read.csv(), and write.csv()\n#\n# Basic Operations:\n# load all files in data directory\n# perform QC\n# write QC report\n# save QCed data file\n\nfun.QCauto <- function() {##FUN.fun.QCauto.START\n  #\n  # Verify input dates, if blank, NA, or null use all data\n  # if DateRange.Start is null or \"\" then assign it 1900-01-01\n  if (is.na(myData.DateRange.Start)==TRUE||myData.DateRange.Start==\"\"){myData.DateRange.Start<-DateRange.Start.Default}\n  # if DateRange.End is null or \"\" then assign it today\n  if (is.na(myData.DateRange.End)==TRUE||myData.DateRange.End==\"\"){myData.DateRange.End<-DateRange.End.Default}\n  #\n  # Read in list of files to work on, uses all files matching pattern (\"\\\\.csv$\")\n  # ## if change formats will have to make modifications (pattern, import, export)\n  files2process = list.files(path=myDir.data.import, pattern=\" *.csv\")\n  head(files2process)\n  #\n  #\n  # Define Counters for the Loop\n  intCounter <- 0\n  intCounter.Stop <- length(files2process)\n  intItems.Total <- intCounter.Stop\n  print(paste(\"Total files to process = \",intItems.Total,sep=\"\"))\n    flush.console()\n  myItems.Complete  <- 0\n  myItems.Skipped   <- 0\n  myFileTypeNum.Air <- 0\n  myFileTypeNum.Water <- 0\n  #\n  # Create Log file\n  ##  List of all items (files)\n  myItems.ALL <- as.vector(unique(files2process))\n  # create log file for processing results of items\n  #myItems.Log <- data.frame(cbind(myItems.ALL,NA),stringsAsFactors=FALSE)\n  myItems.Log <- data.frame(ItemID=1:intItems.Total,Status=NA,ItemName=myItems.ALL)\n  #\n\n\n  # Error if no files to process or no files in dir\n\n\n\n\n  # Start Time (used to determine run time at end)\n  myTime.Start <- Sys.time()\n  #\n  # Perform a data manipulation on the data as a new file\n  # Could use for (n in files2process) but prefer the control of a counter\n  while (intCounter < intCounter.Stop)\n  {##while.START\n    #\n    # 0. Increase the Counter\n    intCounter <- intCounter+1\n    #\n    # 1.0. File Name, Define\n    strFile = files2process[intCounter]\n    # 1.1. File Name, Parse\n    strFile.Base <- substr(strFile,1,nchar(strFile)-nchar(\".csv\"))\n    strFile.parts <- strsplit(strFile.Base,\"_\")\n    strFile.SiteID     <- strFile.parts[[1]][1]\n    strFile.DataType   <- strFile.parts[[1]][2]\n    # Convert Data Type to proper case\n    strFile.DataType <- paste(toupper(substring(strFile.DataType,1,1)),tolower(substring(strFile.DataType,2,nchar(strFile.DataType))),sep=\"\")\n    strFile.Date.Start <- as.Date(strFile.parts[[1]][3],\"%Y%m%d\")\n    strFile.Date.End   <- as.Date(strFile.parts[[1]][4],\"%Y%m%d\")\n    #\n    # 2. Check File and skip if doesn't match user defined parameters\n    # 2.1. Check File Size\n    if(file.info(paste(myDir.data.import,\"/\",strFile,sep=\"\"))$size==0){\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (file blank)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n        flush.console()\n      # go to next Item\n      next\n    }\n    # 2.2. Check SiteID\n    # if not in provided site list then skip\n    if(strFile.SiteID %in% myData.SiteID == FALSE) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, SiteID)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n        flush.console()\n      # go to next Item\n      next\n    }\n    # 2.3. Check DataType\n    # if not equal go to next file (handles both Air and Water)\n    if (strFile.DataType %in% myData.Type == FALSE){\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, DataType)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n        flush.console()\n      # go to next Item\n      next\n    }\n    # 2.4. Check Dates\n    # 2.4.2.1. Check File.Date.Start (if file end < my Start then next)\n    if(strFile.Date.End<myData.DateRange.Start) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, Start Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n        flush.console()\n      # go to next Item\n      next\n    }\n    # 2.4.2.2. Check File.Date.End (if file Start > my End then next)\n    if(strFile.Date.Start>myData.DateRange.End) {\n      # inform user of progress and update LOG\n      myMsg <- \"SKIPPED (Non-Match, End Date)\"\n      myItems.Skipped <- myItems.Skipped + 1\n      myItems.Log[intCounter,2] <- myMsg\n      fun.write.log(myItems.Log,myDate,myTime)\n      fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n        flush.console()\n      # go to next Item\n      next\n    }\n    #\n    # 3.0. Import the data\n    #data.import=read.table(strFile,header=F,varSep)\n    #varSep = \"\\t\" (use read.delim instead of read.table)\n    # as.is = T so dates come in as text rather than factor\n    #data.import <- read.delim(strFile,as.is=TRUE,na.strings=\"\")\n    data.import <- read.csv(paste(myDir.data.import,strFile,sep=\"/\"),as.is=TRUE,na.strings=\"\")\n    #\n    # 4.0. Columns\n    # Check for and add any missing columns (but not for missing data fields)\n    # 4.1. Date, Time, DateTime\n    # list\n    strCol.DT <- c(myName.Date,myName.Time,myName.DateTime)\n    # check for missing\n    strCol.DT.Missing <- strCol.DT[strCol.DT %in% colnames(data.import)==FALSE]\n    # add to df\n    data.import[,strCol.DT.Missing] <- NA\n    # 4.2.  Check for columns present and reorder columns\n    # check for columns present\n    strCol.Present <- myNames.Order[myNames.Order %in% colnames(data.import)==TRUE]\n    # reorder Columns\n    data.import <- data.import[,strCol.Present]\n    # 4.3. Add FLAGS\n    strCol.Flags <- myNames.Flags[myNames.Cols4Flags %in% colnames(data.import)==TRUE]\n    data.import[,strCol.Flags] <- \"\"\n    #\n    #\n    # data columns for flags that are present (need for later)\n    #myNames.Cols4Flags.Present <- myNames.Cols4Flags[myNames.Cols4Flags %in% colnames(data.import)==TRUE]\n    #\n    myNames.DataFields.Present <- myNames.DataFields[myNames.DataFields %in% colnames(data.import)==TRUE]\n    #\n    #\n    #\n    # 5.  QC Date and Time fields\n    #\n    ############\n    # may have to tinker with for NA fields\n    ##############\n    # get format - if all data NA then get an error\n    #\n    # backfill first?\n    #\n    # may have to add date and time (data) from above when add the missing field.\n    #if does not exists then add field and data.\n    #\n    # if entire field is NA then fill from other fields\n    # Date\n    myField   <- myName.Date\n    data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,myName.DateTime]\n    # Time\n    myField   <- myName.Time\n    data.import[,myField][all(is.na(data.import[,myField]))] <- data.import[,myName.DateTime]\n    # DateTime\n    #myField   <- myName.DateTime\n    # can't fill fill from others without knowing the format\n    #\n    # get current file date/time records so can set format\n    # Function below gets date or time format and returns R format\n    # date_time is split and then pasted together.\n    # if no AM/PM then 24hr time is assumed\n    format.Date     <- fun.DateTimeFormat(data.import[,myName.Date],\"Date\")\n    format.Time     <- fun.DateTimeFormat(data.import[,myName.Time],\"Time\")\n    format.DateTime <- fun.DateTimeFormat(data.import[,myName.DateTime],\"DateTime\")\n    # get error if field is NA, need to fix\n    # same for section below\n    #\n    # QC\n    #  # format.Date <- \"%Y-%m-%d\"\n    #   format.Time <- \"%H:%M:%S\"\n    #   format.DateTime <- \"%Y-%m-%d %H:%M\"\n    #\n    # 5. QC Date and Time\n    # 5.1. Convert all Date_Time, Date, and Time formats to expected format (ISO 8601)\n    # Should allow for users to use different time and date formats in original data\n    # almost worked\n    #data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime] <- strftime(data.import[!(is.na(data.import[,myName.DateTime])),][myName.DateTime]\n    #                                                                                   ,format=\"%Y-%m-%d\")\n    # have to do where is NOT NA because will fail if the first item is NA\n    # assume all records have the same format.\n    #\n    # 5.1.1. Update Date to \"%Y-%m-%d\" (equivalent to %F)\n    myField   <- myName.Date\n    myFormat.In  <- format.Date #\"%Y-%m-%d\"\n    myFormat.Out <- myFormat.Date #\"%Y-%m-%d\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n    # 5.1.2. Update Time to \"%H:%M:%S\" (equivalent to %T) (uses different function)\n    myField   <- myName.Time\n    myFormat.In  <- format.Time #\"%H:%M:%S\"\n    myFormat.Out <- myFormat.Time #\"%H:%M:%S\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(as.POSIXct(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n    # 5.1.3. Update DateTime to \"%Y-%m-%d %H:%M:%S\" (equivalent to %F %T)\n    myField   <- myName.DateTime\n    myFormat.In  <- format.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    myFormat.Out <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n                                                                   ,format=myFormat.Out)\n    #   # strptime adds the timezome but drops it when added back to data.import (using format)\n    #   #######################################################\n    #   # doesn't work anymore, worked when first line was NA\n    #   #######################################################\n    #   data.import <- y\n    #   x<-data.import[,myField][!is.na(data.import[,myField])]\n    #   (z<-x[2])\n    #   (a <- strptime(z,format=myFormat.In))\n    #   (b <- strptime(x,format=myFormat.In))\n    #   # works on single record but fails on vector with strftime\n    #   # strptime works but adds time zone (don't like but it works)\n    #\n    #\n    # 5.2. Update DateTime, Date, and Time if NA based on other fields\n    # 5.2.1. Update Date_Time if NA (use Date and Time)\n    myField   <- myName.DateTime\n    myFormat  <- myFormat.DateTime #\"%Y-%m-%d %H:%M:%S\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(paste(data.import[,myName.Date][data.import[,myField]==\"\"]\n    #                                                                       ,data.import[,myName.Time][data.import[,myField]==\"\"],sep=\"\")\n    #                                                                 ,format=myFormat,usetz=FALSE)\n    data.import[,myField][is.na(data.import[,myField])] <- strftime(paste(data.import[,myName.Date][is.na(data.import[,myField])]\n                                                                          ,data.import[,myName.Time][is.na(data.import[,myField])]\n                                                                          ,sep=\" \")\n                                                                    ,format=myFormat,usetz=FALSE)\n    # 5.2.2. Update Date if NA (use Date_Time)\n    myField   <- myName.Date\n    myFormat  <- myFormat.Date #\"%Y-%m-%d\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Date]==\"\"]\n    #                                                               ,format=myFormat,usetz=FALSE)\n    data.import[,myField][is.na(data.import[,myField])] <- strftime(data.import[,myName.DateTime][is.na(data.import[,myField])]\n                                                                    ,format=myFormat,usetz=FALSE)\n    # 5.2.3. Update Time if NA (use Date_Time)\n    myField   <- myName.Time\n    myFormat  <- myFormat.Time #\"%H:%M:%S\"\n    #   data.import[,myField][data.import[,myField]==\"\"] <- strftime(data.import[,myName.DateTime][data.import[,myName.Time]==\"\"]\n    #                                                               ,format=myFormat,usetz=FALSE)\n    data.import[,myField][is.na(data.import[,myField])] <- as.POSIXct(data.import[,myName.DateTime][is.na(data.import[,myField])]\n                                                                      ,format=myFormat,usetz=FALSE)\n    #\n    # old code just for reference\n    # 5.5. Force Date and Time format\n    #   data.import[,myName.Date] <- strftime(data.import[,myName.Date],format=\"%Y-%m-%d\")\n    #   data.import[,myName.Time] <- as.POSIXct(data.import[,myName.Time],format=\"%H:%M:%S\")\n    #   data.import[,myName.DateTime] <- strftime(data.import[,myName.DateTime],format=\"%Y-%m-%d %H:%M:%S\")\n    #\n    #\n    # Create Month and Day Fields\n    # month\n#     myField   <- \"month\"\n#     data.import[,myField] <- data.import[,myName.Date]\n#     myFormat  <- \"%m\"\n#     data.import[,myField][!is.na(data.import[,myName.Date])] <- strftime(data.import[,myName.Date][!is.na(data.import[,myName.DateTime])]\n#                                                                     ,format=myFormat,usetz=FALSE)\n    data.import[,\"month\"] <- as.POSIXlt(data.import$Date)$mon+1\n    # day\n#     myField   <- \"day\"\n#     data.import[,myField] <- data.import[,myName.Date]\n#     myFormat.In  <- myFormat.Date #\"%Y-%m-%d\"\n#     myFormat.Out <- \"%d\"\n#     data.import[,myField][!is.na(data.import[,myField])] <- format(strptime(data.import[,myField][!is.na(data.import[,myField])],format=myFormat.In)\n#                                                                    ,format=myFormat.Out)\n    data.import[,\"day\"] <- as.POSIXlt(data.import$Date)$mday\n    #\n#     # example of classes for POSIXlt\n#     Sys.time()\n#     unclass(as.POSIXlt(Sys.time()))\n#     ?DateTimeClasses\n#\n    # 6. QC for each Data Type present\n    # sub routine adds QC Calcs, QC Test Flags, Assigns overall Flag, and removes QC Calc Fields\n    # cycle each data type (manually code)\n    #\n    # 6.1. WaterTemp\n    myMsg.data <- \"WaterTemp\"\n    myMsg <- paste(\"WORKING (QC Tests and Flags - \",myMsg.data,\")\",sep=\"\")\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    data.import <- fun.CalcQCStats(data.import\n                                  ,myName.WaterTemp\n                                  ,myThresh.Gross.Fail.Hi.WaterTemp\n                                  ,myThresh.Gross.Fail.Lo.WaterTemp\n                                  ,myThresh.Gross.Suspect.Hi.WaterTemp\n                                  ,myThresh.Gross.Suspect.Lo.WaterTemp\n                                  ,myThresh.Spike.Hi.WaterTemp\n                                  ,myThresh.Spike.Lo.WaterTemp\n                                  ,myThresh.Roc.SD.period.WaterTemp\n                                  ,myThresh.RoC.SD.number.WaterTemp\n                                  ,myThresh.Flat.Hi.WaterTemp\n                                  ,myThresh.Flat.Lo.WaterTemp\n                                  ,myThresh.Flat.Tolerance.WaterTemp)\n    # 6.2. AirTemp\n    myMsg.data <- \"AirTemp\"\n    myMsg <- paste(\"WORKING (QC Tests and Flags - \",myMsg.data,\")\",sep=\"\")\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    data.import <- fun.CalcQCStats(data.import\n                                  ,myName.AirTemp\n                                  ,myThresh.Gross.Fail.Hi.AirTemp\n                                  ,myThresh.Gross.Fail.Lo.AirTemp\n                                  ,myThresh.Gross.Suspect.Hi.AirTemp\n                                  ,myThresh.Gross.Suspect.Lo.AirTemp\n                                  ,myThresh.Spike.Hi.AirTemp\n                                  ,myThresh.Spike.Lo.AirTemp\n                                  ,myThresh.Roc.SD.period.AirTemp\n                                  ,myThresh.RoC.SD.number.AirTemp\n                                  ,myThresh.Flat.Hi.AirTemp\n                                  ,myThresh.Flat.Lo.AirTemp\n                                  ,myThresh.Flat.Tolerance.AirTemp)\n    # 6.3. WaterBP\n    myMsg.data <- \"WaterBP\"\n    myMsg <- paste(\"WORKING (QC Tests and Flags - \",myMsg.data,\")\",sep=\"\")\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    data.import <- fun.CalcQCStats(data.import\n                                  ,myName.WaterBP\n                                  ,myThresh.Gross.Fail.Hi.WaterBP\n                                  ,myThresh.Gross.Fail.Lo.WaterBP\n                                  ,myThresh.Gross.Suspect.Hi.WaterBP\n                                  ,myThresh.Gross.Suspect.Lo.WaterBP\n                                  ,myThresh.Spike.Hi.WaterBP\n                                  ,myThresh.Spike.Lo.WaterBP\n                                  ,myThresh.Roc.SD.period.WaterBP\n                                  ,myThresh.RoC.SD.number.WaterBP\n                                  ,myThresh.Flat.Hi.WaterBP\n                                  ,myThresh.Flat.Lo.WaterBP\n                                  ,myThresh.Flat.Tolerance.WaterBP)\n    # 6.4. AirBP\n    myMsg.data <- \"AirBP\"\n    myMsg <- paste(\"WORKING (QC Tests and Flags - \",myMsg.data,\")\",sep=\"\")\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    data.import <- fun.CalcQCStats(data.import\n                                  ,myName.AirBP\n                                  ,myThresh.Gross.Fail.Hi.AirBP\n                                  ,myThresh.Gross.Fail.Lo.AirBP\n                                  ,myThresh.Gross.Suspect.Hi.AirBP\n                                  ,myThresh.Gross.Suspect.Lo.AirBP\n                                  ,myThresh.Spike.Hi.AirBP\n                                  ,myThresh.Spike.Lo.AirBP\n                                  ,myThresh.Roc.SD.period.AirBP\n                                  ,myThresh.RoC.SD.number.AirBP\n                                  ,myThresh.Flat.Hi.AirBP\n                                  ,myThresh.Flat.Lo.AirBP\n                                  ,myThresh.Flat.Tolerance.AirBP)\n    # 6.5. WaterLevel\n    myMsg.data <- \"WaterLevel\"\n    myMsg <- paste(\"WORKING (QC Tests and Flags - \",myMsg.data,\")\",sep=\"\")\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    data.import <- fun.CalcQCStats(data.import\n                                  ,myName.WaterLevel\n                                  ,myThresh.Gross.Fail.Hi.WaterLevel\n                                  ,myThresh.Gross.Fail.Lo.WaterLevel\n                                  ,myThresh.Gross.Suspect.Hi.WaterLevel\n                                  ,myThresh.Gross.Suspect.Lo.WaterLevel\n                                  ,myThresh.Spike.Hi.WaterLevel\n                                  ,myThresh.Spike.Lo.WaterLevel\n                                  ,myThresh.Roc.SD.period.WaterLevel\n                                  ,myThresh.RoC.SD.number.WaterLevel\n                                  ,myThresh.Flat.Hi.WaterLevel\n                                  ,myThresh.Flat.Lo.WaterLevel\n                                  ,myThresh.Flat.Tolerance.WaterLevel)\n    #\n    #############################\n    # Names of columns for QC Calculations and Tests with Flags for each data column present\n    # combine so can check for and remove later.\n    myNames.DataFields.Present.QCCalcs <- as.vector(t(outer(myNames.DataFields.Present,myNames.QCCalcs,paste,sep=\".\")))\n    myNames.Flags.QCTests <- paste(\"Flag.\",as.vector(t(outer(myNames.QCTests,myNames.DataFields.Present,paste,sep=\".\"))),sep=\"\")\n    #################################\n    # not sure if need this little bit anymore\n    ################################\n    #\n    #\n    # 7. QC Tests\n    # incorporated into subroutine in step 6\n    #\n    # 8. Generate QC File\n    # incorporated into subroutine in step 6\n    #\n    # 9. Generate Log File\n    # incorporated into subroutine in step 6\n    #\n    ###########################\n    # save file then run QC Report in a separate Script\n    ###############\n    # 10.0. Output file (only works if DataType is Air OR Water *not* both)\n    # 10.1. Set Name\n    #File.Date.Start <- format(as.Date(myData.DateRange.Start,myFormat.Date),\"%Y%m%d\")\n    #File.Date.End   <- format(as.Date(myData.DateRange.End,myFormat.Date),\"%Y%m%d\")\n    strFile.Out <- paste(\"QCauto\",strFile,sep=\"_\")\n    # 10.2. Save to File the data (overwrites any existing file).\n    #print(paste(\"Saving output of file \",intCounter,\" of \",intCounter.Stop,\" files complete.\",sep=\"\"))\n    #flush.console()\n    write.csv(data.import,file=paste(myDir.data.export,\"/\",strFile.Out,sep=\"\"),quote=FALSE,row.names=FALSE)\n    #\n    # 11. Clean up\n    # 11.1. Inform user of progress and update LOG\n    myMsg <- \"COMPLETE\"\n    myItems.Complete <- myItems.Complete + 1\n    myItems.Log[intCounter,2] <- myMsg\n    fun.write.log(myItems.Log,myDate,myTime)\n    fun.Msg.Status(myMsg, intCounter, intItems.Total, strFile)\n    flush.console()\n    # 11.2. Remove data (import)\n    #rm(data.import)\n    #\n  }##while.END\n  #\n  myTime.End <- Sys.time()\n  print(paste(\"Task COMPLETE; \",round(difftime(myTime.End,myTime.Start,units=\"mins\"),2),\" min.\",sep=\"\"))\n  flush.console()\n  #\n  # return data table\n  return(data.import)\n}##FUN.fun.QCauto.END\n######################################################################\n\n\n\n# # ######################################################################\n# # # QC\nfun.data.import                 <- data.import\nfun.myField.Data                <- myName.WaterLevel\nfun.myThresh.Gross.Fail.Hi      <- myThresh.Gross.Fail.Hi.WaterLevel\nfun.myThresh.Gross.Fail.Lo      <- myThresh.Gross.Fail.Lo.WaterLevel\nfun.myThresh.Gross.Suspect.Hi   <- myThresh.Gross.Suspect.Hi.WaterLevel\nfun.myThresh.Gross.Suspect.Lo   <- myThresh.Gross.Suspect.Lo.WaterLevel\nfun.myThresh.Spike.Hi           <- myThresh.Spike.Hi.WaterLevel\nfun.myThresh.Spike.Lo           <- myThresh.Spike.Lo.WaterLevel\nfun.myThresh.Roc.SD.period      <- myThresh.Roc.SD.period.WaterLevel\nfun.myThresh.RoC.SD.number      <- myThresh.RoC.SD.number.WaterLevel\nfun.myThresh.Flat.Hi            <- myThresh.Flat.Hi.WaterLevel\nfun.myThresh.Flat.Lo            <- myThresh.Flat.Lo.WaterLevel\nfun.myThresh.Flat.Tolerance     <- myThresh.Flat.Tolerance.WaterLevel\n# # ####################################################################\n\n########################\n# FUNCTION\n########################\n# Generate QC Test Calculations, QC Test Flags, and Assign overall flags\n# input is a single data field and the thresholds\n# output is a data frame (assumes data.import)\n# reuses items from this script and calling script.  Not a stand alone function\n#\nfun.CalcQCStats <- function(fun.data.import\n                            ,fun.myField.Data\n                            ,fun.myThresh.Gross.Fail.Hi\n                            ,fun.myThresh.Gross.Fail.Lo\n                            ,fun.myThresh.Gross.Suspect.Hi\n                            ,fun.myThresh.Gross.Suspect.Lo\n                            ,fun.myThresh.Spike.Hi\n                            ,fun.myThresh.Spike.Lo\n                            ,fun.myThresh.Roc.SD.period\n                            ,fun.myThresh.RoC.SD.number\n                            ,fun.myThresh.Flat.Hi\n                            ,fun.myThresh.Flat.Lo\n                            ,fun.myThresh.Flat.Tolerance) {\n  #\n  # A.1. Calc, SD Time Interval\n  myCalc <- \"SD.Time\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  # calculate as separate variable\n  #http://stackoverflow.com/questions/8857287/how-to-add-subtract-time-from-a-posixlt-time-while-keeping-its-class-in-r\n  myT <- strptime(fun.data.import[,myName.DateTime],format=myFormat.DateTime)\n  myT$hour <- myT$hour - fun.myThresh.Roc.SD.period\n  # add back to dataframe\n  fun.data.import[,myField] <- as.character(myT)\n  #\n  # alternate calculation, not used\n  #seq.POSIXt( from=Sys.time(), by=\"-25 hour\", length.out=2 )[2]\n  #\n  # variable for following block\n  myField.T1 <- myField\n  #\n  # A.2. Calc, SD, calc SD of last 25 hours\n  myCalc <- \"SD\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  #myField.T2 <- myName.DateTime\n#   ################\n#   # calc SD\n#   #\n#   #a <- fun.data.import[,myName.WaterTemp]\n#   #b <- fun.data.import[,myName.DateTime]\n#   #sd(a[b<=\"2014-04-22 10:00:00\" & b>=\"2014-01-13 11:00:00\"],na.rm=TRUE)\n#   #sd(a,na.rm=TRUE)\n#   #\n#   fun.data.import[,myField] <- sd(fun.data.import[,fun.myField.Data][fun.data.import[,myName.DateTime]<=\"2014-04-22 10:00:00\" & fun.data.import[,myName.DateTime]>=\"2014-01-13 11:00:00\"],na.rm=TRUE)\n  ################\n  # slow but works (~10 seconds for 5k records)\n  # *******need to change to sapply***********\n  for (m in 1:nrow(fun.data.import)) {\n    fun.data.import[m,myField] <- sd(fun.data.import[,fun.myField.Data][\n        fun.data.import[,myName.DateTime]<=fun.data.import[m,myName.DateTime]\n        & fun.data.import[,myName.DateTime]>=fun.data.import[m,myField.T1]\n        ],na.rm=TRUE)\n  }\n  #\n  # A.3. Calc, NxSD, SD * n.per\n  myCalc.1 <- \"SD\"\n  myCalc.2 <- \"SDxN\"\n  myField.1 <- paste(fun.myField.Data,myCalc.1,sep=\".\")\n  myField.2 <- paste(fun.myField.Data,myCalc.2,sep=\".\")\n  fun.data.import[,myField.2] <- fun.data.import[,myField.1] * fun.myThresh.RoC.SD.number\n  #\n  # A.4. Calc, Diff (1:5) (5 is default but can be more)\n  for (i in 1:myThresh.Flat.MaxComp) {##FOR.j.START\n    #\n    myCalc <- paste(\"n\",i,sep=\".\")\n    myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n    fun.data.import[-(1:i),myField] <- diff(fun.data.import[,fun.myField.Data],lag=i)\n    #\n  }##FOR.i.END\n  #\n  #http://stackoverflow.com/questions/18862114/r-count-number-of-columns-by-a-condition-for-each-row\n  #\n  # A.5. Calc, flat.Hi, count n.1 etc if less than toler\n  myCalc <- \"flat.Hi\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  myThresh <- fun.myThresh.Flat.Hi\n  # Fields to check\n  myFields.Match <- match(paste(fun.myField.Data,\"n\",1:myThresh,sep=\".\"), names(fun.data.import))\n  # use rowSums to count the fields\n  fun.data.import[,myField] <- rowSums(abs(fun.data.import[,myFields.Match])<=fun.myThresh.Flat.Tolerance)\n  #\n  # A.6. Calc, flat.Lo, count if less than toler\n  myCalc <- \"flat.Lo\"\n  myField <- paste(fun.myField.Data,myCalc,sep=\".\")\n  myThresh <- fun.myThresh.Flat.Lo\n  # Fields to check\n  myFields.Match <- match(paste(fun.myField.Data,\"n\",1:myThresh,sep=\".\"), names(fun.data.import))\n  # use rowSums to count the fields\n  fun.data.import[,myField] <- rowSums(abs(fun.data.import[,myFields.Match])<=fun.myThresh.Flat.Tolerance)\n  #\n  ## B. Generate Flags based on Calculation Fields\n  # B.1. Gross\n  myQCTest <- \"Gross\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- 2\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- 9\n  # data >= Suspect.Hi then flag = 3 (suspect)\n  fun.data.import[,myField][fun.data.import[,fun.myField.Data] >= fun.myThresh.Gross.Suspect.Hi] <- 3\n  # data <= Suspect.Lo then flag = 3 (Suspect)\n  fun.data.import[,myField][fun.data.import[,fun.myField.Data] <= fun.myThresh.Gross.Suspect.Lo] <- 3\n  # data >= Fail.Hi then flag = 4 (fail)\n  fun.data.import[,myField][fun.data.import[,fun.myField.Data] >= fun.myThresh.Gross.Fail.Hi] <- 4\n  # data <= Fail.Lo then flag = 4 (fail)\n  fun.data.import[,myField][fun.data.import[,fun.myField.Data] <= fun.myThresh.Gross.Fail.Lo] <- 4\n  # otherwise flag = 1 (pass)\n  fun.data.import[,myField][fun.data.import[,myField]==2] <- 1\n  # QC\n  #table(fun.data.import[,myField])\n  #\n  # B.2. Spike\n  myQCTest <- \"Spike\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"n\",1,sep=\".\")\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- 2\n  # diff 1 is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,myField.Calc.1])==TRUE] <- 9\n  # abs(diff 1) >= spike Lo then flag = 3 (suspect)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) >= fun.myThresh.Spike.Lo] <- 3\n  # abs(diff 1) >= spike Hi then flag = 4 (fail)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) >= fun.myThresh.Spike.Hi] <- 4\n  # otherwise flag = 1 (pass)\n  fun.data.import[,myField][fun.data.import[,myField]==2] <- 1\n  # QC\n  #table(fun.data.import[,myField])\n  #\n  # B.3. RoC\n  myQCTest <- \"RoC\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"n\",1,sep=\".\")\n  myField.Calc.2 <- paste(fun.myField.Data,\"SDxN\",sep=\".\")\n  # Assign Flags\n  # default value\n  fun.data.import[,myField] <- 2\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- 9\n  # sd is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,myField.Calc.1])==TRUE] <- 9\n  # diff 1 > SD*N then flag = 3 (suspect)\n  fun.data.import[,myField][abs(fun.data.import[,myField.Calc.1]) > fun.data.import[,myField.Calc.2]] <- 3\n  # otherwise flag = 1 (pass) [no 4/Fail]\n  fun.data.import[,myField][fun.data.import[,myField]==2] <- 1\n  # QC\n  #table(fun.data.import[,myField])\n  #\n  # B.4. Flat\n  myQCTest <- \"Flat\"\n  myField <- paste(\"Flag\",myQCTest,fun.myField.Data,sep=\".\")\n  myField.Calc.1 <- paste(fun.myField.Data,\"flat.Hi\",sep=\".\")\n  myField.Calc.2 <- paste(fun.myField.Data,\"flat.Lo\",sep=\".\")\n  # default value\n  fun.data.import[,myField] <- 2\n  # Lo >= Thresh.Lo = 3 (suspect)\n  fun.data.import[,myField][fun.data.import[,myField.Calc.2] >= fun.myThresh.Flat.Lo] <- 3\n  # Hi >= Thresh.Hi = 4 (fail)\n  fun.data.import[,myField][fun.data.import[,myField.Calc.1] >= fun.myThresh.Flat.Hi] <- 4\n  # otherwise flag = 1 (pass)\n  fun.data.import[,myField][fun.data.import[,myField]==2] <- 1\n  # QC\n  #table(fun.data.import[,myField])\n  #\n  #\n  # C. Assign Overall Data Flag\n  myField <- paste(\"Flag\",fun.myField.Data,sep=\".\")\n  #myNames.QCTests\n  # get column numbers (match) for QCTest Flags for this data\n  myFields.Match <- match(paste(\"Flag\",myNames.QCTests,fun.myField.Data,sep=\".\"), names(fun.data.import))\n  # Conditional rowSums for number of flag fields with specified flags\n  myFlags.Num.Pass    <- rowSums(fun.data.import[,myFields.Match]==1)\n  myFlags.Num.Suspect <- rowSums(fun.data.import[,myFields.Match]==3)\n  myFlags.Num.Fail    <- rowSums(fun.data.import[,myFields.Match]==4)\n  myFlags.Num.Missing <- rowSums(fun.data.import[,myFields.Match]==9)\n  myFlags.Num.OK      <- rowSums(fun.data.import[,myFields.Match]==1 | fun.data.import[,myFields.Match]==9)\n  # Assign\n  # default value\n  fun.data.import[,myField] <- 2\n  # any QC Test flags = 3 then flag = 3 (suspect)\n  fun.data.import[,myField][myFlags.Num.Suspect > 0] <- 3\n  # any QC Test flags = 4 then flag = 4 (fail)\n  fun.data.import[,myField][myFlags.Num.Fail > 0] <- 4\n  # all QC Test flags = 1 then flag = 1 (pass)\n  fun.data.import[,myField][myFlags.Num.Pass == length(myNames.QCTests)] <- 1\n  # all QC Test flags = 1 or 9 then flag = 1 (pass)\n  fun.data.import[,myField][myFlags.Num.OK == length(myNames.QCTests)] <- 1\n    #fun.data.import[,myField][fun.data.import[,myField]==2] <- 1\n  # data is NA then flag = 9 (missing data)\n  fun.data.import[,myField][is.na(fun.data.import[,fun.myField.Data])==TRUE] <- 9\n  # QC\n  #table(fun.data.import[,myField])\n  #\n  # D. Remove QC Calc fields\n  #myNames.QCCalcs <- c(\"SD.Time\",\"SD\",\"SDxN\",\"n.1\",\"n.2\",\"n.3\",\"n.4\",\"n.5\",\"flat.Lo\",\"flat.Hi\")\n  # get field column numbers\n  myFields.Match <- match(paste(fun.myField.Data,myNames.QCCalcs,sep=\".\"), names(fun.data.import))\n  # drop fields from data table\n  fun.data.import <- fun.data.import[,-na.omit(myFields.Match)]\n\n  #\n  # function output\n  return(fun.data.import)\n}\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1488990541759.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "810302942",
    "id" : "63B760BB",
    "lastKnownWriteTime" : 1489016273,
    "last_content_update" : 1489016273373,
    "path" : "~/tn_realtime/working/R_scripts/libs/fun.QCauto.R",
    "project_path" : "libs/fun.QCauto.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}